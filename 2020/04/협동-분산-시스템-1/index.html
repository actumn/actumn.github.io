<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.62.2 with theme Tranquilpeak 0.4.7-BETA"><meta name=author content="SunMyeong Lee"><meta name=keywords content="tech"><meta name=description content="건국대학교 협동분산시스템 강의노트"><meta property="og:description" content="건국대학교 협동분산시스템 강의노트"><meta property="og:type" content="article"><meta property="og:title" content="협동 분산 시스템 (1)"><meta name=twitter:title content="협동 분산 시스템 (1)"><meta property="og:url" content="https://actumn.github.io/2020/04/%ED%98%91%EB%8F%99-%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-1/"><meta property="twitter:url" content="https://actumn.github.io/2020/04/%ED%98%91%EB%8F%99-%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-1/"><meta property="og:site_name" content="Actumn (SunMyeong Lee)"><meta property="og:description" content="건국대학교 협동분산시스템 강의노트"><meta name=twitter:description content="건국대학교 협동분산시스템 강의노트"><meta property="og:locale" content="ko-kr"><meta property="article:published_time" content="2020-04-26T15:41:22"><meta property="article:modified_time" content="2020-04-26T15:41:22"><meta property="article:section" content="Computer Science"><meta property="article:tag" content="lecture"><meta property="article:tag" content="distributed system"><meta property="article:tag" content="computer science"><meta name=twitter:card content="summary"><meta property="og:image" content="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=640"><meta property="twitter:image" content="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=640"><title>협동 분산 시스템 (1)</title><link rel=icon href=https://actumn.github.io/favicon.png><link rel=canonical href=https://actumn.github.io/2020/04/%ED%98%91%EB%8F%99-%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-1/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin=anonymous><link rel=stylesheet href=https://actumn.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css></head><body><div id=blog><header id=header data-behavior=1><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://actumn.github.io/>Actumn (SunMyeong Lee)</a></div><a class=header-right-picture href=https://actumn.github.io/#about><img class=header-picture src="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=90" alt></a></header><nav id=sidebar data-behavior=1><div class=sidebar-container><div class=sidebar-profile><a href=https://actumn.github.io/#about><img class=sidebar-profile-picture src="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=110" alt></a><h4 class=sidebar-profile-name>SunMyeong Lee</h4><h5 class=sidebar-profile-bio>I love <em>language learning</em>, <em>development</em>, <em>open source</em></h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/><i class="sidebar-button-icon fa fa-lg fa-home"></i><span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/categories><i class="sidebar-button-icon fa fa-lg fa-bookmark"></i><span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/tags><i class="sidebar-button-icon fa fa-lg fa-tags"></i><span class=sidebar-button-desc>Tags</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/archives><i class="sidebar-button-icon fa fa-lg fa-archive"></i><span class=sidebar-button-desc>Archives</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/#about><i class="sidebar-button-icon fa fa-lg fa-question"></i><span class=sidebar-button-desc>About</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/actumn target=_blank rel=noopener><i class="sidebar-button-icon fa fa-lg fa-github"></i><span class=sidebar-button-desc>GitHub</span></a></li></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=1 class=hasCoverMetaIn><article class=post itemscope itemtype=http://schema.org/BlogPosting><div class="post-header main-content-wrap text-left"><h1 class=post-title itemprop=headline>협동 분산 시스템 (1)</h1><div class="postShorten-meta post-meta"><time itemprop=datePublished datetime=2020-04-26T15:41:22+09:00>26, 2020</time>
<span></span><a class=category-link href=https://actumn.github.io/categories/computer-science>Computer Science</a></div></div><div class="post-content markdown" itemprop=articleBody><div class=main-content-wrap><p>건국대학교 협동분산시스템 강의노트</p><h1 id=chapter-1-introduction>Chapter 1. Introduction</h1><ul><li>Two advances in<ul><li>powerful microprocessors &ldquo;무어의 법칙&rdquo;</li><li>HIgh-speed computer networks</li></ul></li></ul><h2 id=분산시스템-정의>분산시스템 정의</h2><ul><li>&ldquo;분산시스템은 독립적인 컴퓨터들이 모여있는 시스템이다. 사용자에게는 1개의 거대한 시스템으로 보인다.&rdquo;</li><li>좋은 품질의 서비스를 제공하기 위해 scalable한 설계.</li><li>Important<ul><li>자율적인 components 로 구성된다.</li><li>유저들은 하나의 시스템이라 생각한다.</li></ul></li><li>분산시스템의 특징<ul><li>여러 컴퓨터의 커뮤니케이션을 유저로부터 숨긴다.</li><li>유저와 애플리케이션의 Interaction은 일관적이고 균일한 방법으로<ul><li>위치와 장소에 관계 없이.</li><li>ex) A방법 -> X기능, B방법 -> Y기능. 아&mldr; 별로다</li></ul></li><li>확장이 요이해야한다. 필요할 때 쉽게 확장<ul><li>독립컴퓨터</li><li>시스템의 확장은 유저로부터 숨긴다.</li></ul></li><li>분산시스템은 continuously available<ul><li>몇몇 부분이 죽더라도 서비스는 돌아가야한다.</li></ul></li></ul></li></ul><h2 id=middleware>Middleware</h2><ul><li>분산시스템은 흔히 쓰이는 소프트웨어 layer의 수단.<ul><li>계층적으로 중간에 있는 소프트웨어</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext>+-------------------------------+
| higer-level layer | - user applications
+-------------------------------+
    |||             
    |||
+-------------------------------+
| Middleware      |
+-------------------------------+
    |||             
    |||
+-------------------------------+
| layers underneath |  - Operating system
+-------------------------------+
</code></pre></div><p><img src=https://actumn.github.io/images/kucse-distributed-system/introduction-middleware.png alt=IMAGE></p><ul><li>Middleware는 일종의 라이브러리라고 생각하자.<ul><li>동일한 interface를 제공</li><li>요청 A -> C: middle api 사용. 서비스요청을 받고 처리까지.</li></ul></li></ul></li><li>사용자입장에서는 분산되어있음을 최대한 숨긴다.<ul><li>그래서 Middleware밑에 필요한 모든걸 숨긴다. interface 역할</li><li>장점: 사용자에게 편리한 인터페이스.</li><li>단점: 퍼포먼스가 떨어진다.</li></ul></li></ul><h2 id=goals>Goals</h2><ul><li>Making resources accessible<ul><li>사용자에게 리모트 서비스 접근을 쉽게, 편리하게 한다.</li></ul></li><li>Distribution transparency<ul><li>process와 resource가 분산되어 있음을 숨긴다.</li><li>너무 엄격하게 적용하면 퍼포먼스가 떨어질 수 있다.</li></ul></li><li>Openness<ul><li>서비스를 표준에 따라 제공하자</li><li>표준: 데이터를 제공하는 방법, 요청하는 방법의 표준</li><li>표준만 따르면 누가 만들어도 쉽게 접근 가능.</li></ul></li><li>Scalability<ul><li>리소스의 사이즈 확장, geographically 확장, administratively 확장 가능한 시스템,</li><li>리소스의 사이즈: 스토리지, 컴퓨팅 파워 -> 많은 수의 사용자</li><li>geographically 확장: 사용자도 그렇고, 시스템도 그렇고, 다양하게 퍼져있어서 어디서나 동일한 품질의 서비스를 제공받을 수 있다.</li><li>administratively 화장: 운영, 정책적인 측면<ul><li>여러 admin이 있을 때 하나의 서비스를 제공할 수 있다면.</li><li>운영, 정책적인 문제가 크다.</li></ul></li></ul></li></ul><h2 id=making-resouce-accessible>Making resouce Accessible</h2><ul><li>그룹웨어. 여러 사요자가 리소스를 share하면서 cscw.<ul><li>computer-supported collaborative work</li></ul></li><li>리모스 액세스 connectivity up.</li><li>security가 점점 더 중요해진다.</li></ul><h2 id=distribution-transparency>Distribution transparency</h2><ul><li>사용자가 서비스를 편하게 이용하기 위해 분산을 숩기는 것이 좋다.</li><li>transparent distributed system<ul><li>분산시스템이 마치 1개의 시스템, 마치 로컬시스템 마냥 이용할 수 있다.</li></ul></li><li>Access -> 데이터 형태, 제공방식이 다르더라도 액세스 방법이 똑같다면</li><li>Location -> 리소스의 위치를 숨긴다.</li><li>Migration -> 리소스가 이동됐음을 숨긴다. (마이그레이션을 숨긴다.)</li><li>Relocation -> 사용 중 리소스가 이동됐음을 숨긴다.</li><li>Replication -> 리소스가 복제됐음을 숨긴다.</li><li>Concurrency -> 리소스가 공유되고 있음을 숨긴다.</li><li>Failure -> failure, recovery를 숨긴다. fault-tolerant 시스템.</li></ul><h3 id=distribution-transparency-types-of-transparancys>Distribution transparency: Types of transparancys</h3><ul><li>Access transparency<ul><li>ex) 다양한 os에서 돌아가는 컴퓨터<ul><li>각각 그들의 file-naming 컨벤션이 있다</li><li>이 네이밍 컨벤션 차이는 유저와 애플리케이션에선 숨겨야한다.</li></ul></li><li>ex) ppt-> 윈도우, 맥 어디서든 편집, view 가능<ul><li>access transparency가 제공된다.</li></ul></li></ul></li><li>Location transparancy<ul><li>리소스의 위치를 숨긴다.</li><li>URL -> A, B</li></ul></li><li>Migration transparancy<ul><li>유저가 사용하지 않을때 밤새 데이터가 이동됐다. 유저는 모른다.</li><li>User -> URL (A(Windows) -> B(Linux))</li></ul></li><li>Relocation transparancy<ul><li>유저가 사용하고 있는데 데이터가 이동됐다.</li><li>모바일 유저 -> wireless 네트워크 (개념상 relocation)<ul><li>이동중에도 잘 쓸 수 있다.</li></ul></li></ul></li><li>Replication transparency<ul><li>리소스 copy를 숨긴다. 리소스 availabilty를 올리기 위해</li><li>ex) 영화 파일 복제 -> 한국 서버, 미국 서버. 유저는 모른다.</li></ul></li><li>Concurrency transparency<ul><li>각 유저가 다른 유저와 같은 자원을 쓰고 있는 것을 모른다.</li><li>**중요한 이슈는 공유자원에 동시접근을 일관되게. -> 같은 파일을 동시에 edit 한다면?</li><li>concurrency control 필요</li></ul></li><li>Failure transpareny<ul><li>fault-tolerant</li><li>죽어서 다시 살아나는 걸 숨긴다. backup.</li></ul></li></ul><h3 id=distribution-transparency-degree-of-transparency>Distribution transparency: Degree of transparency</h3><ul><li>숨기는게 항상 좋은가?</li><li>ex) 전자신문 (적절한 예시는 아니다.)<ul><li>오전 7시에 구독. 그리고 유저가 한국 -> 미국으로 이동했다. (시간대 변경)</li><li>유저가 서비스에 자신의 위치를 알려야한다.</li><li>개인정보 이슈</li></ul></li><li>ex) 분산시스템. 샌프란시스코 &lt;-> 암스테르담.<ul><li>메세지를 35ms안에 보내는 것이 불가능</li><li>빛의 속도라는 물리적 한계.</li></ul></li><li>많이 숨길수록 성능이 떨어진다.<ul><li>Trade-off : Degree of trans parency와 Performance</li><li>ex) Internet application retry.<ul><li>unavailable retry</li><li>계속 기다리는 것보다 unavailable을 알려주는게 나을 수도 있다.</li></ul></li></ul></li><li>적당히 숨기는 게 좋다.<ul><li>ex) 분산 프린터 시스템</li><li>놀고 있는 프린터보다 가까이있는 바쁜 프린터가 좋다.</li></ul></li></ul><h2 id=openness>Openness</h2><ul><li>표준 -> 요청방식, 제공방식</li><li>Standard rule에 따라 서비스를 제공하는 시스템<ul><li>ex) 포맷, 컨텐츠, 메세지 수단. 컴퓨터 네트워크</li></ul></li><li>프로토콜로 정형화 된 rule</li><li>인터페이스를 통해 특화되는 서비스<ul><li>IDL(Interface Definition Language)로 인터페이스를 정의하자.</li><li>Client가 Syntax를 알 수 있다.<ul><li>Function name, parameters, return values</li></ul></li><li>그 서비스가 자세히 무엇을 하는 지는 모름<ul><li>인터페이스의 Sementics</li></ul></li></ul></li><li>Interoperability 상호운용성<ul><li>사용자는 어느 회사에서 만든 서비스건 상관없이 사용이 가능하다. (표준을 이용해서)</li></ul></li><li>Portability 이식성<ul><li>그대로 옮겨도 이용자에게 손쉽게 전달이 가능하다. 표준을 잘 지킨다.</li><li>ex) JVM</li></ul></li><li>Another goal<ul><li>Configure</li><li>컴포넌트 추가/대체</li></ul></li></ul><h3 id=openess-policy과-메커니즘-분리>Openess: policy과 메커니즘 분리</h3><ul><li>좀 더 flexible한 서비스를 위한 분신시스템 디자인</li><li>서비스를 얼마나 flexible하게 만들 수 있는가</li><li>많은 서비스를 보면 모놀리식 (vs. flexbilirt)<ul><li>option을 고려하지 않았다.</li><li>ex) 웹브라우저 캐시. 캐싱서비스가 flexible하지 않다면<ul><li>웹브라우저에서 캐시 사이즈, consistency 체크, 데이터 신선도 정책 설정 가능</li><li>유저는 다른 패러미터 configure는 안된다. (얼마동안 캐시할건지, 캐시가 다 차면 어떤 문서가 삭제될 건지)</li></ul></li></ul></li><li>메커니즘: 서비스 그 자체<ul><li>ex) Web caching<ul><li>parameter를 제공해야 한다.</li></ul></li></ul></li></ul><h2 id=scalability-확장성>Scalability 확장성</h2><ul><li>가장 중요한 목표</li><li>Measurement<ul><li>size<ul><li>유저와 리소스를 쉽게 추가할 수 있다.</li></ul></li><li>geographically<ul><li>유저와 리소스가 멀어질 수 있다.</li></ul></li><li>administratively<ul><li>관리가 쉽다.</li></ul></li><li>다는 못하니 3개중 2개.</li></ul></li></ul><h3 id=scalability-problems-with-the-size>Scalability: Problems (with the size)</h3><ul><li>중앙집중 서비스, 데이터, 알고리즘 제한</li><li>중앙집중 서비스<ul><li>병목, 무제한 프로세스, 스토리지 용량이 있어도 컴니케이션 이슈</li><li>DDoS 서버렉</li></ul></li><li>중앙집중 데이터:<ul><li>SPoF</li><li>ex) 5천만명의 핸드폰 번호</li></ul></li><li>중앙집중 알고리즘<ul><li>single machine에서 돌아가는 알고리즘은 피해야한다.</li><li>분산알고리즘 써야한다.</li></ul></li><li>분산 알고리즘 특징<ul><li>어떤 머신은 시스템에 대한 완전한 정보를 모른다.<ul><li>내가 갖는 input만 갖고 result를 만든다. 컴포넌트 분산</li></ul></li><li>결과는 local information 기반</li><li>머신 하나의 failure가 시스템을 망가트리진 않는다.</li><li>분산 알고리즘은 optimal하지 않다.<ul><li>최적의 결과는 아니지만, 최적에 근접한, 빨리 solution을 찾는 needs.</li></ul></li><li>모든 서버의 clock sync를 맞춰야 한다.<ul><li>동기화를 해야한다.</li><li>communication delay issue.</li><li>피하기 위한 방법?</li></ul></li></ul></li></ul><h3 id=scalability-problems-with-geography>Scalability: Problems (with Geography)</h3><ul><li>Synchronous Communication -> delay. 물리적으로 멀리졌을 때 delay는?<ul><li>node &lt;-> node</li><li>분산시스템은 분산 communication</li><li>client가 reply가 올때까지 block. sync</li><li>&lt;-> async. 기다리면서 딴짓. delay 에서 이득.</li></ul></li><li>WAN에서 Communication은 선천적으로 unreliable<ul><li>Virtually always point-to-point</li><li>버퍼가 가득차면 새로오는 메세지는 버린다. packet drop.</li><li>그래서 TCP를 쓴다. 없어지면 다시 보내도록.</li><li>ex) 분산시스템 서비스를 쓰려면 어떤 서비스가 있는지 알아야한다.<ul><li>어떻게 알아?</li><li>Broadcast는 WAN에선 쓰면 안된다.</li></ul></li></ul></li></ul><h3 id=scalability-problems-with-the-administration>Scalability: Problems (with the administration)</h3><ul><li>기술적인 것보다 어렵다.</li><li>통신사별 같은 서비스라면?<ul><li>1개의 분산 시스템, 여러 회사의 조직</li><li>Security 이슈</li></ul></li></ul><h3 id=scalability-scaling-techniques-스케일링-기법>Scalability: scaling techniques. 스케일링 기법</h3><ul><li>3개의 기법<ul><li>Communication atency를 숨긴다.<ul><li>어떻게? 제일 빨라야 빛의 속도</li><li>메세지를 보낼 필요가 없게 만든다.</li></ul></li><li>Distribution</li><li>Replication</li><li>centralized data 이슈를 기억하자. 데이터를 분산시키고, 복제시켜놓자.</li></ul></li><li>Hiding communication latency<ul><li>요청해서 결과가 오기까지 시간을 줄여보자<ul><li>Sync vs Async</li></ul></li><li>Async: 데이터를 요청하며 다른 task를 한다.<ul><li>다른거 할게 없으면&mldr; 의미 없다</li></ul></li><li>가능한한 횟수를 줄이자.<ul><li>local에서 할 수 있으면 local에서. 필요한 경우 client에서.</li><li>자바 애플릿과 자바스크립트</li></ul></li><li>ex) 이메일, 입력폼, 데이터
<img src=https://actumn.github.io/images/kucse-distributed-system/introduction-scalability-hiding-latency.png alt=IMAGE><ul><li>입력시 포맷확인</li><li>클라이언트 데이터 -> 서버</li><li>서버에서 하던거를 클라에서 하자.</li></ul></li></ul></li><li>Distribution. 전체리소스를 쪼개서 흩뿌린다.<ul><li>컴포넌트</li><li>작은 파트로 쪼개라</li><li>그 부분을 시스템 전체로 퍼트리자.</li><li>좋은 예<ul><li>Domain Name System</li></ul></li><li>DNS (replication도 사용한다.)<ul><li>전세계적으로 서버가 여러대.</li><li>계층적 구조</li><li>Single name server -> each zone</li><li>SPoF도 피할 수 있다.</li></ul></li><li>다른 예 (WWW)<ul><li>web contents 분산.</li></ul></li></ul></li><li>Replication<ul><li>서버가 1개밖에 없으면 load가 많이 걸린다. 죽으면?</li><li>분산, 복제 이슈는 동일</li><li>장점<ul><li>리소스 availabilty up</li><li>로드 밸런스 (컴포넌트 사이에서)</li><li>더 좋은 성능</li><li>geographically widely-dispersed system<ul><li>커뮤니케이션 latency를 숨기기 좋다. (어디에서든 접근)</li></ul></li></ul></li><li>캐싱: Special form of replication<ul><li>클라이언트에서 결정. (다음에도 또 쓸까봐)<ul><li>보통 Replication은 서버측에서 복제를 결정</li></ul></li><li>시점: on demand<ul><li>보통 Replication은 사전에 복제. (사용자가 요청하기 전에)</li></ul></li></ul></li><li>Consistency problems (단점)<ul><li>일관성 문제. (복제된 것들 사이에서 일관성 원본 + 복제)</li><li>원본이 업데이트 되었을때 복제가 갱신되어 있지 않다면?<ul><li>정책.<ul><li>ex) 학과홈페이지 -> 별로 업데이트되지 않는다. -> consistency 정책 1일&mldr; 2일&mldr;</li><li>ex) 주식 -> 복제된 데이터도 critical. 매번 바뀌는 데이터. -> 계속 consitency 체크. 1분? 1초?</li></ul></li></ul></li><li>동시에 2개의 update<ul><li>충돌 이슈.</li><li>sync 메커니즘 필요</li></ul></li></ul></li></ul></li><li>종합<ul><li>사이즈 측면이 가장 쉽다.<ul><li>기술적인 관점에서 가장 문제가 안된다.</li></ul></li><li>Distribution, replication, 그리고 caching 다같이 쓴다.</li><li>Administrative 가 가장 어렵다.<ul><li>기술적이지 않은 부분을 해결해야 한다.</li></ul></li></ul></li></ul><h2 id=pitfalls>Pitfalls</h2><ul><li>쉽게 빠지는 함정</li><li>가정<ul><li>The network is reliable -> TCP로 하면 좀 낫다.</li><li>The network is secure</li><li>The Network is homogeneous -> 동일한 아키텍쳐의 network를 쓴다?</li><li>The topology does not change -> 모바일 디바이스는 항상 위치가 바뀐다.</li><li>Latency is zero -> 딜레이 이슈</li><li>Bandwidth is infinite -> 대역폭은 상황에 따라 달라진다.</li><li>Transport cost is zero -> 전송비용. 상황에 따라 달라진다.</li><li>There is one administrator</li></ul></li></ul><h2 id=types-of-distributed-systems>Types of distributed Systems</h2><ul><li>Distributed computing systems<ul><li>컴퓨팅 파워</li><li>시스템은 CPU가 좋다.</li><li>공학 시뮬레이션, 입자물리 등</li></ul></li><li>Distributed information systems<ul><li>정보제공.</li><li>여러가지. www, 데이터, 게임</li></ul></li><li>Distributed pervasive systems<ul><li>센서데이터, 환경이 dynamic.</li><li>임베디드, 모바일</li></ul></li></ul><h1 id=chapter-2-architectures>Chapter 2. Architectures</h1><ul><li>디자인 시 어떤 부분을 고려해야 하는가.</li><li>분산시스템에서 소프트웨어 컴포넌트를 어떻게 구성해야 하는가.<ul><li>주로 서버단에서.</li></ul></li><li>소프트웨어를 어떤 구조로 만들 것인가.</li><li>Goal<ul><li>분산시스템 애플리케이션과 underlying platform 분리<ul><li>OS&mldr; 하드웨어 리소스&mldr; 애플리케이션이 돌아가는 환경은 다양할 수 있다.</li><li>Separation을 위해 미들웨어.</li></ul></li><li>Distribution transparency</li><li>Adaptability - 상황에 맞게 적응할 수 있는 시스템<ul><li>사용자 취향에 맞는 서비스</li><li>상황에 따라서 변화된 서비스에 맞게</li></ul></li></ul></li></ul><hr><h2 id=architectural-styles>Architectural Styles</h2><ul><li>스타일? 어떤 부분에서 차이? -> 컴포넌트</li><li>소프트웨어 아키텍쳐<ul><li>The logical organization of distributed systems</li></ul></li><li>통짜 소프트웨어 vs 컴포넌트?<ul><li>컴포넌트쪽이 replacable하다.</li></ul></li><li>Connector<ul><li>컴포넌트간의 관계.</li><li>분산시스템에서 프로세스가 컴포넌트</li><li>프로세스간 데이터 교환수단.</li><li>low-level: TCP/UDP<ul><li>RPC, message passing or streaming data</li></ul></li></ul></li><li>Styles<ul><li>Layered architectures</li><li>Object-based architectures</li><li>Data-centered architectures</li><li>Event-based architectures</li></ul></li><li>Distribution transparency<ul><li>distribution transparency를 고려해야한다.</li><li>성능과의 trade-off</li><li>프로그래밍은 쉬워지는데 성능은 구려진다.</li></ul></li></ul><h3 id=layeded-architectures>Layeded architectures</h3><p><img src=https://actumn.github.io/images/kucse-distributed-system/architecture-layered.png alt=IMAGE></p><ul><li>컴포넌트는 layered</li><li>N 레이어 컴포넌트는 N-1레이어 컴포너트 호출로.<ul><li>다른 방법은 x</li></ul></li><li>네트워킹 커뮤니티에서 널리 채택되고 있다.<ul><li>OSI 7layer&mldr;</li></ul></li><li>비효율적일지도. (performance 측면에서)</li></ul><h3 id=object-based-architectures>Object-based architectures</h3><p><img src=https://actumn.github.io/images/kucse-distributed-system/architecture-object-based.png alt=IMAGE></p><ul><li>좀더 loose. 제약이 없다.</li><li>(remote) procedure call</li><li>client-server 시스템 아키텍쳐.</li></ul><h3 id=data-centered-architecture>Data-centered architecture</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>(app 1) write -&gt; (db) -&gt; read (app 2)
</code></pre></div><ul><li>중앙에 데이터 repository가 존재<ul><li>컴포넌트간 데이터를 주고받을 repository</li></ul></li><li>컴포넌트는 repository 한테서 데이터를 받아간다.</li><li>Web기반 분산시스템이 data-centric<ul><li>직접 전달하면 되지 않나?</li><li>언제, 어디서 사용할지 모르니까, 언제, 어디서든 접근할 수 있게</li></ul></li></ul><h3 id=event-based-architectures>Event-based architectures</h3><p><img src=https://actumn.github.io/images/kucse-distributed-system/architecture-event-based.png alt=IMAGE></p><ul><li>데이터를 전달하려는 컴포넌트 &ldquo;메세지를 지금 보낼테니 지금 당장 필요한 컴포넌트가 써라&rdquo;</li><li>미들웨어 - 이벤트 버스</li><li>&ldquo;어떤 데이터를 받고자 하는지&rdquo;</li><li>누구에게 전달? pub/sub 시스템</li><li>모든 component사이의 &ldquo;관심사가 등록되어 있다.</li><li>IoT에서 sensor data -> 뿌려준다.<ul><li>통신 프로토콜 MQTT</li></ul></li><li>&ldquo;관심사"에서 업데이트가 있을 때 바로 받을 수 있다.</li><li>Data-centered와 비교<ul><li>Data-centered는 두 component가 모두 online일 필요가 없다.</li><li>Event bus에서 저장하면 된다.<ul><li>pure event-based에선 전달의 역할. 저장x</li><li>저장해봐야 소용이 없는, 그 순간에 필요한 데이터</li><li>&ldquo;그 순간의 온도정보&rdquo;, 누가 쓸지 모르는</li></ul></li></ul></li><li>Event-based + data-centered architecture
<img src=https://actumn.github.io/images/kucse-distributed-system/architecture-event-data-centered.png alt=IMAGE><ul><li>subscribe는 해뒀는데 당장 online이 아니다.<ul><li>repository에 저장해놓자.</li></ul></li></ul></li></ul><h3 id=분산시스템이-노리적물리적으로-어디에-위치해-있어야-하는가-역할은>분산시스템이 노리적/물리적으로 어디에 위치해 있어야 하는가, 역할은?</h3><ul><li>Centralized architectures<ul><li>server-client</li></ul></li><li>Decentralized architectures<ul><li>클라/서버 역할 구분이 없다.</li></ul></li><li>Hybrid architectures</li><li>유의.<ul><li>centralized - data-centered</li><li>decentralized - event-based</li><li>다른 관점이다.</li></ul></li></ul><h3 id=centralized-architectures>Centralized architectures</h3><ul><li>client-server 모델.<ul><li>request-reply의 반복
<img src=https://actumn.github.io/images/kucse-distributed-system/architecture-server-client.png alt=IMAGE></li></ul></li><li>서버와 클라이언트 통신. (모든 서비스가 서버에 집중되어 있다.)<ul><li>TCP? UDP?</li></ul></li><li>Connection protocol (ex. UDP)<ul><li>빨리 보낼 수 있다. 보내고 끝. 유실 가능성</li><li>메세지가 없어질 수 있다. 고려 필요.<ul><li>transmission failure 탐지. 재전송</li></ul></li><li>Client -> Server<ul><li>wait reply. 그런데 reply가 안온다면?</li><li>request 유실? reply 유실?</li><li>reply유실의 경우<ul><li>서버는 request를 잘 처리했다. request가 다시 와도 되겠는가.</li></ul></li><li>&ldquo;내 은행 계좌에서 1000$ wjsthd&rdquo;<ul><li>server에서 state를 바꾸는 request</li><li>not idempotent</li></ul></li><li>&ldquo;내 돈이 얼마나 남았나&rdquo;<ul><li>state 조회. 반복되서 실행되도 문제 없다.</li><li>idempotent</li></ul></li></ul></li><li>같은 subnet 환경이라면 UDP여도 큰 문제가 없다.</li></ul></li><li>Connection-oridented protocols (TCP)<ul><li>90% 이상 TCP<ul><li>TCP가 알아서 메세지 전달 잘 해준다.</li></ul></li><li>사전작업이 필요하다. connection<ul><li>오래걸리는 이유</li></ul></li></ul></li></ul><h3 id=centralized-architectures-application-layering>Centralized architectures: application layering</h3><ul><li>메인 이슈<ul><li>어떤 컴포넌트가, 서버에 적합할지 클라에 적합할지.<ul><li>클라에서 돌릴까 서버에서 돌릴까</li><li>역할을 분명히 해야하지만.</li><li>ex) 서버가 여러개?<ul><li>계층적으로 1서버가 다른 서버의 클라가 될 수도 있다.</li></ul></li><li>크게 3가지로 나누어 지더라.<ul><li>The user-interface level</li><li>The processing level</li><li>The data level</li></ul></li></ul></li></ul></li><li>The user-interface level<ul><li>어떻게 상호작용 할 것인가.</li><li>user &ldquo;input&rdquo; 수단. 처리결과 &ldquo;output&rdquo; 역할<ul><li>Display management</li></ul></li><li>클라이언트단 구현<ul><li>가장 단순하고 중요하다.</li><li>Text만 뿌려주는 것만으로도 UI가 되기도.</li><li>Text기반, GUI기반&mldr;</li></ul></li><li>사요자에게 보여주려는 데이터는 UI레벨에서 가공할 수 있다.<ul><li>UI 역할도 독립적으로 UI만이 아닌 processing과 상호작용으로내부적인 processing이 있을 수 있다.</li></ul></li></ul></li><li>The processing level<ul><li>아마 가장 중요할 듯. 데이터를 찾아주고 계산해주고.</li><li>공통된 기능이 별로 없다. (UI는 공통된게 많을 듯.애플리케이션에 관계 없이)</li><li>ex) Internet search engine. 중앙집중 분산시스템<ul><li>UI: text</li><li>processing: 페이지를 찾자. ranking 알고리즘</li><li>data: web pages.
<img src=https://actumn.github.io/images/kucse-distributed-system/architecture-centralized-searchengine.png alt=IMAGE></li></ul></li><li>ex) a decision support system for stack brokerage<ul><li>주가 데이터 분석/예측</li></ul></li><li>ex) desktop package<ul><li>워드프로세서, 액셀, 파워포인트</li></ul></li></ul></li><li>The data level<ul><li>persistent 데이터</li><li>애플리케이션이 계산할 데이터</li><li>서버측에 두는 게 일반적 (중앙집중형)</li><li>consistency transparency<ul><li>consistency가 깨질 수 있다. read, write conflict</li><li>복제된 데이터 sync</li><li>애플리케이션 특성에 따라 달라진다.</li></ul></li><li>rdb 많이 썼다.</li></ul></li></ul><h3 id=centralized-architectures-multi-tiered-architectures>Centralized architectures: Multi-tiered architectures</h3><ul><li>Three logical levels supports<ul><li>UI</li><li>processing</li><li>data</li></ul></li><li>단순한 구현<ul><li>client -> UI</li><li>server -> processing, data</li><li>이렇게 단순하지 않을 수 있다. 많은 구분이 있을 수 있다.
<img src=https://actumn.github.io/images/kucse-distributed-system/architecture-centralized-multi-tiered.png alt=IMAGE></li></ul></li><li>(a)<ul><li>client: 사용자가 주는 input을 서버로 전달할 뿐. lightweight</li><li>server: 사용자가 요청한 서비스를 client에게 보내기 전에 visualization을 server에서 조금 하자</li></ul></li><li>(b)<ul><li>client는 processing을 하지 않는다.<ul><li>client에서도 processing하는 게 좋다. 오늘날 일반적이지 않다.</li></ul></li></ul></li><li>(c)<ul><li>overall communication latency를 줄이기 위해 클라이언트에서 processing을 하자</li><li>ex) word proessor<ul><li>basic editing</li><li>스펠링 체크, 문법 -> 서버, 도움말</li></ul></li></ul></li><li>(d), (e)<ul><li>UI와 processing을 모두 client에서. server는 데이터만.</li><li>client가 무겁다.</li><li>인기 있는 구성인가? 아닌듯.</li><li>ex) banking application<ul><li>ATM</li></ul></li><li>e) ex) web 클라이언트 캐시</li></ul></li><li>Multi-tiered architectures
<img src=https://actumn.github.io/images/kucse-distributed-system/architecture-centralized-multi-tiered-transaction.png alt=IMAGE><ul><li>application server가 database server 입장에서는 클라이언트</li></ul></li></ul><h2 id=decentralized-architectures>Decentralized architectures</h2><ul><li>Vertical distributions -> 중앙집중에서 고민하던 분산</li><li>Horizontal distributions -> 모든 노드가 client/server<ul><li>peer-to-peer</li><li>왜?<ul><li>client-server</li><li>peer-to-peer</li><li>일장일단이 있다.</li></ul></li><li>서버가 없다. 동등한 역할의 노드들.<ul><li>데이터는 어디에 두지?</li><li>내가 필요한 서비스를 누구에게서 찾지?</li></ul></li><li>client-server구조의 문제 SPoF.<ul><li>서버의 부하가 크고 서버가 맛이가면 서비스가 죽는다.</li><li>Scalability 이슈</li></ul></li><li>peer-to-peer<ul><li>peer 하나가 없어져도 서비스는 문제가 없다.</li><li>훤씬 확장성이 크다.<ul><li>데이터를 누가?</li><li>서비스를 누가?</li><li>peer들 끼리의 역할분담.</li></ul></li></ul></li></ul></li></ul><h3 id=decentralized-architectures-structured-p2p>Decentralized architectures: Structured-P2P</h3><ul><li>모든 노드가 클라이자 서버다.</li><li>피어들간의 overlay network를 어떻게 구성할 것인가?<ul><li>overlay network: 논리적인 노드들, 프로세스들 사이에 연결이 맺어진 네트워크.</li><li>물리적인 연결은 다를 수 있다&mldr; 수많은 router</li><li>관리가 어렵다. 순수한 P2P는 없다. 중간에 서버등에서 데이터를 받아서&mldr;. 서버의 도움을 받는 경우가 많다.</li><li>어떻게 연결하지?<ul><li>blockchain</li><li>peer들 끼리 다 연결? 일부만? -> 다양한 P2P 알고리즘</li></ul></li><li>Structured/Unstructured P2P<ul><li>구조적 연결 rule - structured</li><li>rule 없이 random - unstructured</li></ul></li><li>다 연결하면 fully connected<ul><li>연결이 너무 많아진다.</li><li>모든 connection을 맺진 말자.</li><li>필요한 peer들 기리 통신은 할 수 있는 연결을 만들자.</li><li>직접적인 connection이 됮 않는 경우도 발생</li></ul></li><li>ex) &ldquo;Chord System&rdquo;<ul><li>P2P application에서 P2P연결을 고민하고 싶지 않다.</li><li>overlay network. chord가 알아서 해주겠다. 필요한 데이터.</li></ul></li></ul></li><li>Structured P2P<ul><li><p>rule을 만들때 <code>distributed hash table (DHT)</code> - key-hash-value</p></li><li><p>DHT-based system</p><ul><li>peer들 끼리: 누가 어떤 데이터를 담당할 것인가. (서버단에서 하던거)</li><li>peer들 끼리: 데이터를 어떻게 나눌 것인가.</li><li>테이블을 쪼개서 나누자.</li><li>key를 알면 key를 관리하는 peer를 알 수 있다.</li><li>peer들 끼리 데이터를 쪼개서 관리한다<ul><li>DHT</li></ul></li><li>필요한 노드들에게 키를 할당<ul><li>무작정 random은 아니고, key를 할당.</li></ul></li><li>hash function<ul><li>A -> (hash) -> key</li><li>모든 peer가 같은 hash function을 쓴다.</li><li>모든 peer는 같은 key에서 같은 data를 얻는다.</li></ul></li><li>peer들도 id를 hash해서, key값이 존재</li><li>데이터 lookup하려면<ul><li>local에서 key를 구하고</li><li>p2p에서 이 key를 관리하는 peer를 찾고 &ldquo;A는 이 peer에서 관리하고 있어&rdquo;</li></ul></li></ul></li><li><p>ex) the Chord System
<img src=https://actumn.github.io/images/kucse-distributed-system/architecture-decentralized-p2p-chord.png alt=IMAGE></p><ul><li>노드들 사이 overlay network는 ring형태</li><li>노드는 양쪽 노드와 연결 (2개 노드)<ul><li>successor, predecessor</li></ul></li><li>새로운 노드는 어떻게 참여하지?<ul><li>노드 id, 데이터 key</li><li>K를 관리할 노드는 K보다 크거나 같은 노드 id중 가장 작은 노드 의 노드</li><li>Lookup(k)<ul><li>succ(k)가 뭔지 찾아보자.</li></ul></li></ul></li><li>Membership management<ul><li>peer가 들어올 수도 있고 나올 수 있다.</li><li>그때그때 상황이 바뀐다. 어떻게 관리할 것인가?</li></ul></li></ul></li><li><p>불편하지만 장단점이 있다.</p><ul><li>client/server의 문제점: server가 죽으면 어떡할 것인지? 서버가 강해야한다.</li><li>p2p: peer가 죽어도 전체가 마비되지 않는다. 확장성을 이루기 좋다.</li></ul></li></ul></li></ul><h3 id=decentralized-architectures-unstructured-p2p>Decentralized architectures: Unstructured-P2P</h3><ul><li>주먹구구식으로 P2P 구성 randomized algorithm</li><li>어떤 peer와 연결? 어떤 데이터를 관리? -> random</li><li>각각의 노드는 neighbor의 리스트를 관리. 이웃 노드들</li><li>overlay rule이 없다. 임의의 peer끼리 연결. 개수도 모르고</li><li>데이터를 어떻게 찾지?<ul><li>lookup을 어떻게?<ul><li>To flood the network: 전 네트워크에 모두 물어본다.</li><li>broadcast -> 네트워크가 혼잡해진다.</li><li>WAN에서는 router레벨에서 broadcast가 막혀있다.</li></ul></li></ul></li><li>멤버쉽 관리?<ul><li>각자가 갖고있는 neighbor 정보를 업데이트 - 노드가 뭐가 있는지 알 수 있다.</li><li>새 노드가 참여하기 위해서? broadcast. 노드탐색, 정기적 갱신.</li></ul></li><li>장점은?<ul><li>partial view: neighbor 정보 교환, 업데이트</li><li>문제점을 보완하기 위한 시도들 (다중 서버 구조, P2P)</li></ul></li><li>Super peer -> 서버를 두겠다. 완전한 서버는 아니고, P2P가 섞여있다.<ul><li>다른 peer보다 더 강력한 정보, 강력한 power</li><li>superpeer가 없을때 peer를 찾기 위해 broadcast, flooding 해야한다.</li><li>물어볼 상대를 두자. superpeer (special node)<ul><li>어떻게 찾지? 합의&mldr; 정하는 알고리즘. distributed</li></ul></li><li>데이터를 찾기 위해 일단 superpeer에게 물어보자</li></ul></li></ul><h3 id=decentralized-architectures-hybrid-architectures>Decentralized architectures: Hybrid architectures</h3><ul><li>Centralized (client-server) + Decentralized (P2P)</li><li>장점만 뽑아쓰자.</li><li>필요할 때 서버에 물어보고,</li><li>피어끼리 정보교환하고</li><li>BitTorrent<ul><li>&ldquo;tit-for-tat&rdquo;<ul><li>배반하지 않는 한 최대한 협조.</li></ul></li><li>파일을 주고 받는건 P2P<ul><li>다운을 받으면서 upload, 서로서로 도우면서 하자.</li><li>파일을 많이 제공했으면 그만큼 빨리 받는다.</li></ul></li><li>노드를 찾는건 client-server
<img src=https://actumn.github.io/images/kucse-distributed-system/architecture-bittorrent.png alt=IMAGE></li></ul></li></ul><h3 id=architectures-vs-middleware>Architectures vs Middleware</h3><ul><li>Middleware<ul><li>overlay network찾기, 네트워크 통신 등 지저분한거 middleware가 다 해주겠다.</li><li>(+)application 설계/개발이 simple해진다. 제공해주는 서비스 쓰자. Distribution Transparency</li><li>(-)Middleware라는 추가 layer가 생긴다. performace가 떨어진다.<ul><li>ex) CORBA. object message broker<ul><li>app - (CORBA) - app</li><li>무겁다. 너무 많은 서비스. 느려지더라.</li><li>아키텍쳐가 고정적이었다.</li></ul></li></ul></li><li>A better approach<ul><li>configure, adapt, customize가 쉬워야한다.</li><li>동적으로 behavior를 바꿀 수 있게.</li><li>애플리케이션에 맞게 policy 또는 mechanism을 변경</li><li>policy는 쉬운데, mechanism을?</li></ul></li></ul></li><li>Self-management<ul><li>좋은 아키텍쳐: 적응형으로 mechanism을 바꿀 수 있다면</li><li>automatic adaption</li><li>3가지 종류의 컴포너트가 필요하더라<ul><li>Monitoring -> 상황이 바뀌었음을 알아야한다.</li><li>Analyzing the measumrements. Input/output 분석<ul><li>서비스에 대한 상황이 문제는 없는지, 성능이 떨어짖니 않았는지</li></ul></li><li>Influencing the behavior<ul><li>소프트웨어의 behavior를 상황에 맞게 바꿔라.</li></ul></li></ul></li><li>Monitoring<ul><li>클라이언트-서버 딜레이 체크</li></ul></li><li>Analyzing measurements<ul><li>시스템 output을 정해진 값과 비교. threshold.</li><li>딜레이가 100ms보다 크지는 않은지.</li></ul></li><li>Influencing the behavior<ul><li>replica를 하나 더 두자</li><li>Scheduling 우선 순위</li><li>서비스 switching</li><li>Data migration</li></ul></li></ul></li></ul><h1 id=chapter-3-processes>Chapter 3. Processes</h1><ul><li>Virtualization<ul><li>최근에 인기를 얻게 됐다.</li></ul></li></ul><h2 id=threads---concurrent>Threads - concurrent</h2><ul><li>The granularity of processes<ul><li>다중 프로세스</li></ul></li><li>The granularity of threads<ul><li>다중 스레드. 프로세스 하나에 동시에 돌아가는 효과.</li><li>물론 싱글코어라면 실제로 동시에 돌리는건 아니다.</li><li>사용자 입장에선 동시에 돌아가는 것으로 보인다.</li></ul></li><li>ex) 채팅프로그램<ul><li>최소 2개의 프로세스.<ul><li>keyboard input thread,</li><li>받아서 화면에 뿌려주는 thread</li></ul></li></ul></li><li>멀티프로세스 vs 멀티스레드 cost비교.<ul><li>멀티스레드가 유리. context switch 오버헤드가 적기 떄문</li></ul></li><li>Introduction to threads (or process) 프로세스가 실행되려면, 스레드가 하나 있어야<ul><li>process, thread도 리소스 (소프트웨어 리소스)<ul><li>OS가 관리한다.</li></ul></li><li>program - 파일 상태, 실행이 되면 process<ul><li>실행이 된 process는 OS가 관리<ul><li>여러가지 정보 - PCB, CPU register, memory map, fd list</li></ul></li><li>프로세스 -> 메모리 생성<ul><li>아무데나 하는게 아닌, OS로부터 할당받는다.</li><li>프로세스 사이에 메모리 침법이 일어나지 않도록</li></ul></li></ul></li><li>다중 프로세스, 쓰레드를 통한 concurrency<ul><li>사용자가 눈치채지 못한다 - transparancy</li><li>OS가 알아서 complete independant address를 할당.</li></ul></li><li>컨텍스트 스위치 비용이 프로세스가 상대적으로 비싸다<ul><li>CPU 1개 - 프로세스 변환 -> 다시 실행이 될 때</li><li>실행정보 save -> pc, stack, register -> load</li><li>OS 레벨에서 컨텍스트 스위치에 필요한 데이터 수정<ul><li>가상메모리면 memory translation cache 초기화</li></ul></li><li>새로 실행할 프로세스 load, (thread가 더 가볍다)<ul><li>이 비용이 thread에 비해 비싸다.</li></ul></li><li>프로세스 스왑<ul><li>메인메모리와 하드디스크 스왑</li><li>&ldquo;가상메모리&rdquo; -> 필요한 정보 모두 load를 못했다.</li><li>물리적 메모리가 부족해서, 필요한 것만 load</li><li>(퍼포먼스 개떡락)</li></ul></li></ul></li></ul></li><li>A thread<ul><li>실행 흐름 프로세스 - 1 thread</li><li>concurrent 동작을 위해 thread를 더 만들 수도 있다.</li><li>thread 객체의 크기가 process에 비해 적다</li><li>process-process 메모리 침범 보호 (OS가 보호)</li><li>thread-thread 공유하는 메모리. 막 시도할 수 있다.<ul><li>OS는 침범을 막을 mechanism(lock)만 제공.</li><li>잘 짜야한다. application developer가.</li></ul></li></ul></li><li>다중 쓰레드?<ul><li>다중 프로세스와 비교했을때 더 적은 cost</li><li>잘 짜야한다. 충돌을 OS가 막아주지 않는다.</li></ul></li><li>싱글 쓰레드?<ul><li>쓰레드를 쓰지 않는 그냥 작성한 프로그램</li><li>blocking system call 반복.<ul><li>process performance가 떡락할 수 있다.</li></ul></li><li>다 single thread로 만들 수는 있는데, 이상한 프로그램이 된다.</li><li>ex) excel<ul><li>input 받아야 계산&mldr;</li><li>input 받아야 하는데 계산&mldr;</li><li>single thread면 input, 계산..</li><li>cell이 바뀌면 다른 cell도 바뀌는데&mldr;</li></ul></li></ul></li></ul><h3 id=threads-in-distributed-systems>Threads: in distributed systems</h3><ul><li>분산시스템에서 스레드의 역할은?</li><li>컴퓨터 내 스레드가 아닌 여러 컴퓨터 내 프로세스와 쓰레드.</li><li>편하게 blocking system call 지원 (멀티 프로세스/스레드)<ul><li>전체 process는 block시키지 않으면서.</li></ul></li><li>분산시스템일때는 communication aspect이 들어간다.<ul><li>다중 스레드로 분산시스템 성능이 향상될 수 있다.</li><li>I/O 등.</li></ul></li><li>multithread - client<ul><li>클라이언트 multithread -> communication delay down</li><li>To hide the delay. 숨길수도 있다.<ul><li>ex) web browser<ul><li>연결을 맺고, web document 요청/응답</li><li>web document: text, image, video, contents, 사이즈가 크니 delay가 클 수 있다.</li><li>실제로 연결해보면 text는 금방보고, images는 나중에</li><li>출력하는 thread, contents receive thread 별도로</li><li>사용자는 text를 오래 기다리지 않아도 된다.</li><li>connection을 1개만 두지 말고, 여러개 만들어서 사용자가 요청한 컨텐츠를 parallel하게 받자.</li></ul></li></ul></li></ul></li><li>multithread -server<ul><li>멀티쓰레드의 효과는 서버가 더 크다.</li><li>서버는 거의 필수로 써야한다. high-performance를 위해서.</li><li>언제나 high performance? 사용자가 많이 몰렸을때.</li><li>ex) file server<ul><li>file open, read, update, request</li><li>실제 operation은 전부 server에서.</li><li>file I/O 작업을 해야한다. blocking.</li></ul></li><li>싱글쓰레드로 할 수는 있겠는데, blocking.
<img src=https://actumn.github.io/images/kucse-distributed-system/process-multithread-fileserver.png alt=IMAGE><ul><li>Dispatcher.<ul><li>클라이언트에게 request를 받아서 worker에게 task를 넘겨준다.</li></ul></li><li>Worker.<ul><li>Dispatcher에게 task를 받는다.</li><li>read / write / update</li><li>blocking system call을 알아서 잘해라.</li></ul></li><li>Worker하나가 blocking 된다고 프로세스가 멈추지 않는다.</li><li>Dispatcher가 다른 worker에게 주면 되니까.</li></ul></li><li>다중쓰레드가 아니면<ul><li>main loop이 하나, request 하나 받아서 처리, I/O 대기, 알려주고, 반복</li><li>DISK I/O 하나가 오래 걸리는 거면, 프로세스 하나가 멈춘다.</li><li>blocking system call을 쓰지 않으면 성능이 향상될 수 있다.</li></ul></li><li>non-blocking system call을 이요<ul><li>thread가 하나임에도 다른 thread와 유사하게 가능</li><li>blocking -> I/O를 기다린다.</li><li>non-blocking -. 바로 return이 된다.<ul><li>읽을 수 있는지 없는지 try.</li><li>읽을 수 있으면 읽고 return, 없으면 그냥 return</li></ul></li><li>asyncronous system call일 수도.<ul><li>async는 요청해놓고 바로 return을 받아서 다른 걸 한다.<ul><li>읽어줘. 나는 다른걸 할게.</li></ul></li></ul></li><li>non-blcoking은 계속 tracking해야한다.<ul><li>나중에 check - state 유지</li><li><ol><li>먼저 request 받는다.</li></ol></li><li><ol start=2><li>task 수행을 해야한다면 I/O -> I/O 시스템콜 수행, async, non-blocking</li></ol></li><li><ol start=3><li>다음 클라이언트 (I/O는 처리중)</li></ol></li><li><ol start=4><li>non-blocking 시스템콜이면 이번에 안됨 -> 다음에 다시처리 (반복)</li></ol></li><li>thread는 blocking 되지 않는다.</li></ul></li><li>쓰레드가 너무 많은 것도 오버헤드.<ul><li>Threads<ul><li>parallelism, blocking</li></ul></li><li>Single-threaded process<ul><li>No parallelism, blocking</li></ul></li><li>Finite stete machine<ul><li>Parallelism, nonblocking</li></ul></li></ul></li><li>개발하려는 서버의 특성에 맞게.</li></ul></li></ul></li></ul><h2 id=virtualization>Virtualization</h2><ul><li>illusion</li><li>CPU는 1개인데 동시에 실행되는 듯한 환상.</li><li>자원을 가상화.</li><li>가상화의 역할 (윈도우 쓰고 있는데 리눅스가 쓰고 싶어)
<img src=https://actumn.github.io/images/kucse-distributed-system/process-virtualization.png alt=IMAGE><ul><li>A를 B에서 어떻게 돌리지?<ul><li>porting&mldr;</li><li>layer를 두자! -> 가상화. 다른 시스템을 흉내낸다.<ul><li>느려진다는 문제점.</li></ul></li></ul></li></ul></li><li>Architectures of virtual machines
<img src=https://actumn.github.io/images/kucse-distributed-system/process-virtualization-architecture.png alt=IMAGE><ul><li>가상화.<ul><li>인터페이스의 behavior를 흉내내겠다.</li></ul></li><li>Two ways of virtualization<ul><li>A process virtual machine
<img src=https://actumn.github.io/images/kucse-distributed-system/process-virtualization-virtual-machine.png alt=IMAGE><ul><li>다른 플랫폼에서 돌아가는 application에 필요한 abstract instruction을 제공한다.</li><li>JVM</li><li>emulation 하는 개념?</li></ul></li><li>A virtual machine monitor (VMM)
<img src=https://actumn.github.io/images/kucse-distributed-system/process-virtualization-machine-monitor.png alt=IMAGE><ul><li>Hardware 전체를 제어할 수 있는 interface, OS 여러개 설치 가능</li><li>Application이 직접 Hardware에 access가 가능. 이쪽이 더 성능이 좋다.</li></ul></li><li>VMM 기술이 좀 더 중요해 질 수 있다. 확장 가능성.<ul><li>대신 어렵다. 잘 되면 reliability, security up.</li></ul></li><li>ex) windows 시스템을 VMM 위에서 돌리고 있었다.<ul><li>그리고 해킹을 당했다. 바이러스</li><li>전체 시스템에 영향을 주는건 아니고, window만.</li><li>다른 linux들은 영향 최소화.</li></ul></li><li>portability<ul><li>hardware와 software의 중간 layer</li><li>hardware 교체하기 훨씬 편하다. maintance up</li></ul></li></ul></li></ul></li></ul><h2 id=clients-network-user-interfaces>Clients: Network user interfaces</h2><ul><li>Client machine의 major task.<ul><li>UI 제공. 사용자대신 서버에 요청, 요청수단.</li></ul></li><li>2가지 방법
<img src=https://actumn.github.io/images/kucse-distributed-system/process-network-user-interface.png alt=IMAGE><ul><li>(a) application-specific<ul><li>client가 하는 일이 더 많다.</li><li>ex) 일정관리 프로그램. 전용 프로토콜</li><li>application이 꼭 필요한 경우 (b)는 제공하기 어렵다</li></ul></li><li>(b) application-independant<ul><li>Middleware가 제공하는 common한 서비스만 이용하겠다.</li><li>ex) terminal을 통해서 middleware가 제공하는 것만 하자.</li><li>Client가 하는게 거의 없다.<ul><li>UI만 하겠다.</li></ul></li><li>processing은 모두 서버에서.</li></ul></li></ul></li></ul><h2 id=clients-client-side-software>Clients: Client-side software</h2><ul><li>단순히 UI만 제공하는 건 아니고, UI 이상의 task, role</li><li>자체적인 데이터 관리, processing</li><li>ATM, 셋탑박스.</li></ul><h3 id=clients-transparency>Clients: transparency</h3><ul><li>Distribution transparancy<ul><li>클라이언트도 이를 제공하면 좋다.<ul><li>사용자가 프로그램을 이용하는데, 서버와 연결한다는 것 자체를 모른다.</li><li>Local 프로그램을 사용하는 것 처럼, 이상적인 환경</li></ul></li><li>Server단에선 performance 측면을 봤을 때 distribution transparency를 client보다는 덜 제공하자.</li><li>상황에 맞게, 적당히</li></ul></li><li>Access transparancy. 동일한 방법으로 연결<ul><li>client stub을 이요해서 middleware의 서비스를 이용<ul><li>액세스 방법이 다른 esource가 있다고 해도 client stub이 이를 제공</li><li>same interface<ul><li>access transparancy 제공</li></ul></li></ul></li></ul></li><li>Location, migration, relocation transparancy<ul><li>middleware가 숨긴다.<ul><li>사용자는 모른채로</li></ul></li><li>replication transparency도 middleware가 숨긴다.<ul><li>replicated servers</li><li>replicated requests
<img src=https://actumn.github.io/images/kucse-distributed-system/process-clients-transparency-replication.png alt=IMAGE></li></ul></li></ul></li><li>Failure transparancy<ul><li>클라이언트 미들웨어를 통해 서버와의 communication failure를 숨긴다.</li><li>ex) 반복적 재연결 시도.<ul><li>여러번 실패하면 다른 서버로</li></ul></li><li>ex) 연결은 실패했지만, 캐시된 데이터를 제공</li></ul></li></ul><h2 id=servers-general-design-issues>Servers: General design issues</h2><ul><li>클라이언트는 사용자 편의성</li><li>서버는 클라이언트에게 서비스를 편하게 빨리<ul><li>performance가 주된 이슈</li></ul></li><li>Interative server?<ul><li>process가 하나</li><li>thread가 하나</li></ul></li><li>Concurrent Server<ul><li>다중 쓰레드</li><li>Interative보다 성능이 좋다.</li><li>멀티 프로세스가 대안<ul><li>UNIX. -> 요청에 따라 fork</li></ul></li></ul></li><li>어떻게 편하게 클라이언트에게 서비스를 제공할 것인가?<ul><li>performance보다는 client 편의성 측면</li><li>표준 port -> FTP(21), HTTP(80) well-known port</li><li>표준이 아닌 port 번호라면?<ul><li>섭에 물어보는 절차가 필요할 수 있다.
<img src=https://actumn.github.io/images/kucse-distributed-system/process-server-dynamic-assign.png alt=IMAGE></li></ul></li></ul></li><li>리소스의 낭비는?<ul><li>클라이언트가 없는게 계속 돌고 있어야한다.</li><li>이 리소스 낭비를 해결 항 방법<ul><li>프로세스를 평소엔 돌리지 않다가, 요청하면 프로세스를 돌려라.</li><li>UNIX inetd daemon</li><li>필요할 때만 프로세스가 생성이 되서 서비스를 제공한다.</li></ul></li></ul></li><li>중간에 client가 사정이 생겨서 요청한 서비스를 중단 시킬 수 있을까? (Interrupt)<ul><li>메신저 - 메세지 취소, 메일</li><li>Simple solution: 클라이언트 강제 종료
-server는 client가 강제종료 됐구나. 하고 연결을 끊을 것.</li><li>better approach: out-of-band data<ul><li>non-out-of-band: 클라이언트가 정상적으로 주고받을 때 쓰는 데이터</li><li>out-of-band: 그 이외. 긴급 메세지를 사용해 취소.</li></ul></li><li>긴급 connectionㅔ서 out-of-band<ul><li>리소스 낭비. 원래 쓰던 connection에선 못하나?</li><li>TCP header -> out-of-band</li><li>TCP header를 안쓰면?<ul><li>그냥 보내면 순서가 밀린다.</li><li>non-blocking system call이면 가능하겠다.</li></ul></li></ul></li></ul></li><li>Stateful / stateless 서버<ul><li>stateful: 클라이언트 상태를 저장하는 서버</li><li>stateless: 그냥 request 오면 처리하는 서버</li><li>stateless 서버<ul><li>장점: 현재 연결된 클라이언트와 아무런 연관 정보가 없다.<ul><li>서버의 상태변경이 클라이언트에 영향을 미치지 않는다.</li><li>stateful은 클라이언트에 영향을 끼치게 된다. 관리가 복잡해진다.</li><li>ex) web server<ul><li>웹브라우저의 상태정보를 저장하지 않는다. (원래는)</li><li>웹메일, 쇼핑몰, &mldr; 백엔드에서 클라이언트 정보를 저장할 수도. 쿠키</li></ul></li><li>실제로는 client information을 유지하는 경우가 대부분이다.</li><li>ex) 클라이언트 request logs<ul><li>날라가도 전체서비스에 큰 영향은 없는 정도.</li></ul></li></ul></li></ul></li><li>Stateless와 Stateful의 중간단계. soft state<ul><li>저장을 하긴 하겠다. limited time 동안.</li><li>서버가 state를 바꾸면 client에 이를 통지한다. (push)<ul><li>limited time이 지나면 통지하지 않는다.</li></ul></li></ul></li><li>Stateful<ul><li>클라이언트에 대한 정보를 활용해서 서비스를 좀 더 효율적으로<ul><li>performance 측면에서</li><li>ex) file server maintain a table containing (client, file) entries<ul><li>클라이언트가 파일에 액세스하는 순간 다 기록하겠지.</li><li>어떤 클라이언트가 어떤 파일에 access 하는지.</li><li>(+) 클라이언트가 이 서버에 있는 파일에 대해서 read/write operation performance 향상. -> 클라이언트가 1파일에 대해 계속 요청. state 유지. file을 open한 채로 둔다.</li><li>(-) 서버가 크래쉬가 나면 테이블의 정보가 날라가고, 복구가 까다로워진다.</li><li>똑같은 file server를 statelss로 구현하려면.<ul><li>loop를 돌면서 write&mldr;</li><li>file open-write-close 매번 찾아서.</li><li>서버가 느려지는 가장 주된 원인은 I/O -> network I/O, file I/O.</li></ul></li></ul></li></ul></li></ul></li><li>서버를 구현한다고 하면 보통 stateful.<ul><li>어떤식의 서비스건 동일하게 수행할 수 있어야 한다.</li><li>퍼포먼스 / 클라이언트 편의성</li><li>ex) 다시 그 파일서버<ul><li>stateful: open file 정보를 유지</li><li>stateless: read/write request 가 온다면<ul><li>매번 파일을 열어서 read/write, 그리고 close</li><li>메세지 크기도 커질 수 있다.</li></ul></li></ul></li><li>ex) 클라이언트의 과거 상태 정보도 안다면, 더 퀄리티 향상이 가능<ul><li>쇼핑몰, 과거 구매이력을 ㅗ추천</li><li>stateless라면 클라이언트가 추가정보를 전송해야한다.<ul><li>cookie</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id=server-cluster-다중-서버>Server cluster: 다중 서버.</h2><ul><li>어떻게 구성하지?</li><li>서버머신이 많아졌을 때 한 곳에 모아놓고 고속망으로 연결.</li><li>물리적으로 server들을 local LAN으로 연결.</li><li>3가지 역할, 3tier<ul><li>First tier</li><li>Second tier</li><li>Third tier
<img src=https://actumn.github.io/images/kucse-distributed-system/process-server-cluster.png alt=IMAGE></li></ul></li><li>server cluster가 여러 서비스르 ㄹ제공할 때<ul><li>다른 머신에서 다른 application이 돌아가는 상황</li><li>switch가 복잡해진다. 서비스 종류를 구분할 수 있어야 한다.</li></ul></li><li>Access Transparancy 고려. 사용 편의성을 위해<ul><li>client는 동일한 방법으로 request를 날려서 reply를 받을 수 있어야 한다.</li><li>server는 client에게 1개의 access point를 제공<ul><li>A 서비스 a port, B 서비스 b port면 access transparancy가 꺠진다.</li></ul></li><li>scalability, availability를 위해선 여러 access point를 제공하는 것이 좋다.<ul><li>사용가능한 access point는 여러개, client에겐 변경되지 않는 1개의 access point 제공</li><li>서버쪽에서 access point가 바뀌어도 clinet에게 알려주지 않도록.</li></ul></li><li>어떻게?<ul><li>TCP
<img src=https://actumn.github.io/images/kucse-distributed-system/process-server-cluster-switch.png alt=IMAGE><ul><li>Transport-layer switch에서 TCP 연결 요청을 받아서, 다른 서버의 연결로 넘겨준다.</li><li>client에게는 1개의 access point, 실제 processing은 다른 노드 일 수도</li><li>실제 서버가 client로 reply를 날려줄 때 보내는 놈의 주소를 자신이 아닌 switch의 주소로 넣는다.</li><li>client는 &ldquo;switch가 보내줬구나"라고 판단.</li><li>TCP hand off는 OS레벨 support가 필요. 그냥 application에선 어렵다.</li><li>왜 하지 이짓을?<ul><li>client에게 single access point 제공</li></ul></li></ul></li></ul></li><li>Load distribution among servers<ul><li>놀고 있는 서버를 잘 찾아서 request 배분<ul><li>Simple solution: Round robin</li><li>Advanced server selection: 서버 상태 monitoring 스위치</li><li>One step further<ul><li>request packet을 뜯어서</li><li>request의 종류 뿐만 아니라 client에 대한 정보도 확인, 적절한 서버에 넘겨준다</li><li>content-aware request distribution</li></ul></li></ul></li></ul></li></ul></li><li>distributedservers:<ul><li>single access point의 문제<ul><li>point가 fail나면 클러스터 전체가 unvailable이 된다.</li><li>solution<ul><li>여러 backup access point<ul><li>DNS 호스트 name은 1개, 여러 ip를 mapping할 수 있다.</li><li>이걸 클라이언트에 그대로 적용하면<ul><li>아, access point가 여러개네</li><li>물론 client middleware가 application 모르게 할 수 있다.</li></ul></li><li>클라이언트에게 1개의 static access point를 제공하고자 하는 청학엔 맡지 않다.</li><li>statble하고 static한 1개의 access point&mldr; desirable feature</li></ul></li><li>Flexible server cluster<ul><li>access point 역할을 하는 놈이 죽으면 다른놈이 하도록 하자. -> distributed server</li><li>서버가 dynamic하게 바뀔 수 있다. access point도 바뀔 수 있다.</li><li>client는 동일한 방법으로 접근 할 수 있다.</li></ul></li></ul></li></ul></li><li>server cluster에서 구성이 좀더 flexible해졌다.<ul><li>client가 stable한 server의 service를 이용할 수 있나.</li><li>server는 cluster 형태. 그때그때 역할을 대신할 수 있다. client에게는 이를 숨긴다.</li><li>어떻게 하지?</li></ul></li><li>MIPv6. Mobile IPv6. 지역이 바뀌어도 IP는 그대로.<ul><li>home network에서 home address 할당받은 디바이스.</li><li>speical router<ul><li>외부에서 오는 트래픽은 모두 home agent를 거친다.</li><li>문제는 Mobile device가 이동할 수 있다. -> home address는 더이상 쓸 수 없다.</li><li>임시로 새로 받는 주소 care-of-address. 이를 자신의 home agent에게 알려준다.</li><li>hom agent가 forward를 해준다. mobile device는 계속해서 트래픽을 받을 수 있다. 어디에 있든 상관 없이.</li></ul></li><li>stable access point<ul><li>&ldquo;A"라는 contact address.</li><li>노드 1개가 contact address를 사용하여 access point 역할</li><li>이 ccess point 노드는 자신의 주소를 agent에게 등록한다.</li><li>모든 트래픽은 B로 간다. B가 분배<ul><li>B가 죽으면 다른 노드가 다시 등록을 한다.</li></ul></li><li>Bottleneck 문제<ul><li>Home agent, access point가 트래픽을 다 받는다.</li></ul></li><li>Solution: 모든 트래픽이 agent를 거치지 않게끔 하자.</li></ul></li></ul></li><li>Solution: route optimization feature<ul><li>MIPv6<ul><li>home agent가 care-of address를 클라이언트에게 알려주자.</li><li>client가 (HA, CA) pair를 갖는다</li><li>home agent의 부담이 줄어든다<ul><li>이상하다. 클라이언트가 이걸 모르게 하려고 했는데.</li></ul></li><li>이 pair는 client application이 아닌 client middleware에서 유지한다.</li><li>middleware가 HA를 CA로 바꿔서 보낸다.</li><li>Application은 계속 HA를 쓰고, MIPv6가 HA를 CA로 바꿔서 쓴다.</li></ul></li><li>Distributed system<ul><li>access point를 여러개 만들자.</li><li>Home agent에 트래픽이 몰리는건 어쩔 수 없다.</li><li>트래픽이 한곳에 몰리는 케이스는 막을 수 있다.</li></ul></li></ul></li></ul></li></ul></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small"></span><br><a class="tag tag--primary tag--small" href=https://actumn.github.io/tags/lecture/>lecture</a>
<a class="tag tag--primary tag--small" href=https://actumn.github.io/tags/distributed-system/>distributed system</a>
<a class="tag tag--primary tag--small" href=https://actumn.github.io/tags/computer-science/>computer science</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/06/computer-network-2/ data-tooltip="Computer Network (2)"><i class="fa fa-angle-left"></i><span class="hide-xs hide-sm text-small icon-ml"></span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/04/computer-network-1/ data-tooltip="Computer Network (1)"><span class="hide-xs hide-sm text-small icon-mr"></span><i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions><i class="fa fa-share-alt"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread><i class="fa fa-comment-o"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#><i class="fa fa-list"></i></a></li></ul></div><div id=disqus_thread><noscript>Please enable JavaScript to view the <a href=//disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2020 SunMyeong Lee.</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=1><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/06/computer-network-2/ data-tooltip="Computer Network (2)"><i class="fa fa-angle-left"></i><span class="hide-xs hide-sm text-small icon-ml"></span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/04/computer-network-1/ data-tooltip="Computer Network (1)"><span class="hide-xs hide-sm text-small icon-mr"></span><i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions><i class="fa fa-share-alt"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread><i class="fa fa-comment-o"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#><i class="fa fa-list"></i></a></li></ul></div></div><div id=share-options-bar class=share-options-bar data-behavior=1><i id=btn-close-shareoptions class="fa fa-close"></i><ul class=share-options></ul></div><div id=share-options-mask class=share-options-mask></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-remove"></i></div><img id=about-card-picture src="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=110" alt><h4 id=about-card-name>SunMyeong Lee</h4><div id=about-card-bio>I love <em>language learning</em>, <em>development</em>, <em>open source</em></div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Student</div><div id=about-card-location><i class="fa fa-map-marker"></i><br>Seoul, Korea</div></div></div><div id=cover style=background-image:url(https://actumn.github.io/images/cover-v1.2.0.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin=anonymous></script><script src=https://actumn.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js></script><script lang=javascript>window.onload=updateMinWidth;window.onresize=updateMinWidth;document.getElementById("sidebar").addEventListener("transitionend",updateMinWidth);function updateMinWidth(){var sidebar=document.getElementById("sidebar");var main=document.getElementById("main");main.style.minWidth="";var w1=getComputedStyle(main).getPropertyValue("min-width");var w2=getComputedStyle(sidebar).getPropertyValue("width");var w3=getComputedStyle(sidebar).getPropertyValue("left");main.style.minWidth=`calc(${w1} - ${w2} - ${w3})`;}</script><script>$(document).ready(function(){hljs.configure({classPrefix:'',useBR:false});$('pre.code-highlight > code, pre > code').each(function(i,block){if(!$(this).hasClass('codeblock')){$(this).addClass('codeblock');}
hljs.highlightBlock(block);});});</script><script>var disqus_config=function(){this.page.url='https:\/\/actumn.github.io\/2020\/04\/%ED%98%91%EB%8F%99-%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-1\/';this.page.identifier='\/2020\/04\/%ED%98%91%EB%8F%99-%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-1\/'};(function(){if(window.location.hostname=="localhost"){return;}
var d=document,s=d.createElement('script');var disqus_shortname='hugo-tranquilpeak-theme';s.src='//'+disqus_shortname+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script></body></html>