<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.62.2 with theme Tranquilpeak 0.4.7-BETA"><meta name=author content="SunMyeong Lee"><meta name=keywords content="tech"><meta name=description content="건국대학교 컴퓨터네트워크 강의노트
Computer Networking: A Top down Approach"><meta property="og:description" content="건국대학교 컴퓨터네트워크 강의노트
Computer Networking: A Top down Approach"><meta property="og:type" content="article"><meta property="og:title" content="Computer Network (1)"><meta name=twitter:title content="Computer Network (1)"><meta property="og:url" content="https://actumn.github.io/2020/04/computer-network-1/"><meta property="twitter:url" content="https://actumn.github.io/2020/04/computer-network-1/"><meta property="og:site_name" content="Actumn (SunMyeong Lee)"><meta property="og:description" content="건국대학교 컴퓨터네트워크 강의노트
Computer Networking: A Top down Approach"><meta name=twitter:description content="건국대학교 컴퓨터네트워크 강의노트
Computer Networking: A Top down Approach"><meta property="og:locale" content="ko-kr"><meta property="article:published_time" content="2020-04-26T15:02:48"><meta property="article:modified_time" content="2020-04-26T15:02:48"><meta property="article:section" content="Computer Science"><meta property="article:tag" content="lecture"><meta property="article:tag" content="computer science"><meta property="article:tag" content="computer network"><meta name=twitter:card content="summary"><meta property="og:image" content="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=640"><meta property="twitter:image" content="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=640"><title>Computer Network (1)</title><link rel=icon href=https://actumn.github.io/favicon.png><link rel=canonical href=https://actumn.github.io/2020/04/computer-network-1/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin=anonymous><link rel=stylesheet href=https://actumn.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','G-YLQBPNSK9Y','auto');ga('send','pageview');}</script></head><body><div id=blog><header id=header data-behavior=1><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://actumn.github.io/>Actumn (SunMyeong Lee)</a></div><a class=header-right-picture href=https://actumn.github.io/#about><img class=header-picture src="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=90" alt></a></header><nav id=sidebar data-behavior=1><div class=sidebar-container><div class=sidebar-profile><a href=https://actumn.github.io/#about><img class=sidebar-profile-picture src="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=110" alt></a><h4 class=sidebar-profile-name>SunMyeong Lee</h4><h5 class=sidebar-profile-bio>I love <em>language learning</em>, <em>development</em>, <em>open source</em></h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/><i class="sidebar-button-icon fa fa-lg fa-home"></i><span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/categories><i class="sidebar-button-icon fa fa-lg fa-bookmark"></i><span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/tags><i class="sidebar-button-icon fa fa-lg fa-tags"></i><span class=sidebar-button-desc>Tags</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/archives><i class="sidebar-button-icon fa fa-lg fa-archive"></i><span class=sidebar-button-desc>Archives</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/#about><i class="sidebar-button-icon fa fa-lg fa-question"></i><span class=sidebar-button-desc>About</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/actumn target=_blank rel=noopener><i class="sidebar-button-icon fa fa-lg fa-github"></i><span class=sidebar-button-desc>GitHub</span></a></li></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=1 class=hasCoverMetaIn><article class=post itemscope itemtype=http://schema.org/BlogPosting><div class="post-header main-content-wrap text-left"><h1 class=post-title itemprop=headline>Computer Network (1)</h1><div class="postShorten-meta post-meta"><time itemprop=datePublished datetime=2020-04-26T15:02:48+09:00>26, 2020</time>
<span></span><a class=category-link href=https://actumn.github.io/categories/computer-science>Computer Science</a></div></div><div class="post-content markdown" itemprop=articleBody><div class=main-content-wrap><p>건국대학교 컴퓨터네트워크 강의노트<br>Computer Networking: A Top down Approach</p><h1 id=chapter-1-introduction>Chapter 1: Introduction</h1><ul><li>인터넷, 프로토콜</li><li>네트워크 엣지: 엔드시스템, 액세스 망, 링크</li><li>네트워크 코어: 패킷스위칭, 서킷스위칭, 네트워크 구조</li><li>성능: 딜레이, 손실, throughput</li><li>프로토콜 레이어, 서비스 모델</li><li>보안</li></ul><hr><h2 id=1-인터넷>1. 인터넷</h2><p><img src=https://actumn.github.io/images/kucse-computer-network/introduction-network.png alt=IMAGE></p><ul><li>수십 억대의 컴퓨팅 디바이스.<ul><li>PC, Server, wireless laptop, smartphone</li><li>호스트: end systems</li><li>네트워크 앱을 실행한다. (apache, nginx &mldr; )</li></ul></li><li>커뮤니케이션 링크<ul><li>fiber, copper, radio, satlelite</li><li>전송율: bandwidth</li></ul></li><li>패킷 스위치<ul><li>라우터, 스위치</li></ul></li><li>인터넷: &ldquo;network of networks&rdquo;<ul><li>ISP가 서로 연결되어 있음</li></ul></li><li>프로토콜: Control sending/receiving of messages<ul><li>TCP, IP, HTTP - 국제표준 오픈 프로토콜, 소유권 x</li><li>Skype - Property 프로토콜.</li></ul></li><li>인터넷 표준<ul><li>RFC</li><li>IETF</li></ul></li><li>Service View<ul><li>애플레키에션에 서비스를 제공하는 인프라<br>Web, VoIP, email, gaems, e-commerce, social nets, &mldr;</li><li>애플레키에션에 프로그래밍 인터페이스를 제공</li></ul></li><li>프로토콜이란<br>packet -> header | payload<br>header -> dest, source &mldr;<ul><li>format 정의</li><li>메세지 전송/수신 순서 정의</li><li>어떤 메세지를 받았을 때 취하는 액션 정의
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-internet-protocol.png alt=IMAGE></li></ul></li></ul><h2 id=2-네트워크-엣지>2. 네트워크 엣지</h2><p><img src=https://actumn.github.io/images/kucse-computer-network/introduction-network.png alt=IMAGE></p><ul><li>네트워크 엣지:<ul><li>호스트: 클라이언트와 서버</li><li>서버는 보통 데이터센터</li></ul></li><li>액세스 네트워크, 물리 매체<ul><li>wired/wireless communication links</li></ul></li><li>네트워크 코어<ul><li>Interconnected routers</li><li>&ldquo;network of networks&rdquo;</li></ul></li><li>엣지 시스템을 엣지라우터에 연결?<ul><li>residential access nets</li><li>institutional access networks</li><li>mobile access networks</li></ul></li><li>Keep in mind<ul><li>Bandwidth(bits/second) of access network?</li><li>Shared of dedicated?<ul><li>shared: 공유</li><li>dedicated: 각자의 bandwidth</li></ul></li></ul></li></ul><h3 id=access-network-digital-subscriber-line-dsl>Access network: digital subscriber line (DSL)</h3><p><img src=https://actumn.github.io/images/kucse-computer-network/introduction-access-net-dsl.png alt=IMAGE></p><ul><li>ADSL: Asymetrical. 다운로드 > 업로드. common case.</li><li>SDSL: Symetrical. 다운로드 = 업로드. ex) Youtube streamer</li></ul><h3 id=access-network-cable-network>Access network: cable network</h3><p><img src=https://actumn.github.io/images/kucse-computer-network/introduction-access-net-cable.png alt=IMAGE></p><h3 id=access-network-home-network>Access network: home network</h3><p><img src=https://actumn.github.io/images/kucse-computer-network/introduction-access-net-home.png alt=IMAGE></p><h3 id=access-network-enterprise-ethernet>Access network: Enterprise (Ethernet)</h3><p><img src=https://actumn.github.io/images/kucse-computer-network/introduction-access-net-ethernet.png alt=IMAGE></p><ul><li>라우터를 통해 L3로</li><li>왼쪽 Ethernet switch<ul><li>부분적으로 보면 Access network</li><li>전체적으로 보면 Edge network</li></ul></li><li>서버<ul><li>클라우드나 데이터센터에 위치</li><li>메일 서버, 웹서버</li></ul></li><li>L3 라우터</li><li>L2 스위치</li></ul><h3 id=access-network-wireless>Access network: Wireless</h3><ul><li><p>shared wireless acess network는 엔드시스템을 라우터에 연결 시킨다.</p></li><li><p>WireLess LAN
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-access-net-wireless-1.png alt=IMAGE></p><ul><li>공유기</li></ul></li><li><p>Wide-area wireless access
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-access-net-wireless-2.png alt=IMAGE></p><ul><li>기지국</li><li>3G, 4G:LTE</li></ul></li></ul><h3 id=hosts-데이터-패킷을-보낸다>Hosts: 데이터 패킷을 보낸다</h3><ul><li>패킷 전송지연
$$ (패킷전송delay) = (L-bit패킷전송에 필요한시간) = L(bits) / R(bits/sec) $$</li><li>R: transmission rate, bandwidth<ul><li>ex) 10G, 1G/s => 10초 걸린다.</li></ul></li></ul><h3 id=물리-매체>물리 매체</h3><ul><li>bit</li><li>physical link</li><li>wired<ul><li>guided media: 유선<ul><li>구리, 광섬유, 동축케이블(coax)</li><li>twisted pair<ul><li>절연 구리줄, 구리줄 8개</li><li>꼬아놔야 간섭을 안한다.</li><li>category 5: 100Mbps, 1Gbps</li><li>category 6: 10Gbps</li></ul></li></ul></li><li>ungided media: 무선<ul><li>라디오</li></ul></li></ul></li><li>coax, coaxical cable<ul><li>동축케이블</li><li>broadband라고 불린다. 주파수 분할을 하므로</li><li>HFC. 가까이 올때까지 fiber, 와서는 copper</li><li>구리줄 -> 전파장. 간섭 및 에러율 증가.</li></ul></li><li>fiber optic cable<ul><li>광섬유 -> 빛. 에러율 감소.<ul><li>중간에 세기가 약하진다.</li><li>리피터가 필요하다.</li><li>노이즈가 적다</li></ul></li></ul></li><li>radio<ul><li>양방향</li><li>소리를통해</li><li>반사 때문에 작은신호(노이즈)가 이따금씩</li><li>장애물, 간섭</li><li>types<ul><li>지상파 microwave</li><li>LAN</li><li>wide-area: 4G</li><li>satelite: 인공위성<ul><li>kbps ~ 45Mbps</li><li>270ms e2e delay.</li><li>전자위성 vs 저궤도 위성</li></ul></li></ul></li></ul></li></ul><h2 id=3-네트워크-코어>3. 네트워크 코어</h2><ul><li><p>패킷 스위칭</p><ul><li>애플리케이션 layer 메세지를 패킷으로 쪼갠다.</li><li>store-and-forward
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-core-packet-store-forward.png alt=IMAGE><ul><li>링크가 available일 시 전송</li><li>라우터는 목적지 계산 (라우팅)<ul><li>링크가 available 될 떄까지 저장 - store</li><li>링크가 available 일 시 전송 - forward</li></ul></li></ul></li><li>queueing delay, loss
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-core-packet-queue.png alt=IMAGE><ul><li>큐: 저장</li><li>전송 속도가 따라가지 못해서 버퍼가 가득 차면 패킷 드랍</li><li>UDP라면 다시 보내지 않는다. error</li><li>TCP라면 다시 보낸다.</li></ul></li><li>routing, forwarding
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-core-packet-routing.png alt=IMAGE><ul><li>routing: source-destination 경로 결정</li><li>forwarding: router input을 적절한 output으로 packet을 옮긴다.</li></ul></li></ul></li><li><p>서킷 스위칭
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-core-circuit.png alt=IMAGE></p><ul><li>사용중인 회선은 다른 곳에서 쓸 수 없다.</li><li>대신 bandwidth가 다 자기꺼.</li><li>traditional telephone networks<ul><li>요즘은 VoIP</li></ul></li><li>FDM vs TDM
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-core-circuit-fdm-tdm.png alt=IMAGE><ul><li>FDM: 주파수 분할 다중화</li><li>TDM: 시분할 다중화</li></ul></li></ul></li><li><p>패킷 스위칭 vs 서킷 스위칭
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-core-packet-vs-circuit.png alt=IMAGE></p><ul><li>패킷 스위칭이 더 많은 유저를 쓸 수 있게 해준다.</li><li>ex)<ul><li>1Mb/s link</li><li>each user<ul><li>100kb/s when &ldquo;active&rdquo;</li><li>active 10% of time</li></ul></li><li>circuit switching<ul><li>10 users</li></ul></li><li>packet switching<ul><li>10명이 넘어가도 store and forward</li><li>35명의 유저라도 10개선을 동시에 쓸 확률은 낮다. (0.0004 ?)</li></ul></li></ul></li></ul></li><li><p>패킷 스위칭이 승자다.</p><ul><li>bursty data<ul><li>리소스 sharing</li><li>간단, UDP의 경우 call setup이 없다.</li></ul></li><li>excessive <strong>congesting</strong> possbile<ul><li>패킷 지연, 손실 가능성</li><li>프로토콜이 packet switching을 염두에 두어야 한다.<ul><li>error, retry</li></ul></li></ul></li><li>circuit-like behavior?<ul><li>VoIP, video transfer</li><li>bandwidth 보장이 필요</li></ul></li></ul></li><li><p>Internet structure: network of networks</p><ul><li>액세스 망, access ISP</li><li>경제, 국가 정책에 따라 발전</li><li>각 ISP마다 connect?
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-structure-networks.png alt=IMAGE><ul><li>O(n^2)연결</li></ul></li><li>Global ISP?
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-structure-global-ISP.png alt=IMAGE><ul><li>각 나라마다 정책</li><li>전세계 cover ISP는 불가능</li></ul></li><li>지역별 ISP
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-structure-regional-ISP.png alt=IMAGE><ul><li>ISP끼리 연결이 안된다.</li></ul></li><li>지역별 Interconnected ISP - IXP
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-structure-regional-IXP.png alt=IMAGE><ul><li>같은 계층에 속한 라우터 - peering</li><li>ISP가 복잡해지면?</li><li>Internet exchange point<ul><li>2개 이상 ISP연결. 다자간 연결</li><li>IXP 센터</li><li>서울 POP, 대전 POP &mldr;</li></ul></li></ul></li><li>아직 전세계 cover는 되지 않는다. + regional net.
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-structure-regional-net.png alt=IMAGE><ul><li>미국, 러시아, 동남아시아 &mldr;</li><li>미국 서부 regional net + 미국 동부 regional net</li><li>미국 전역 cover ISP</li><li>아시아 전역 cover ISP</li><li>동북아시아 regional net</li><li>(+) backbone 망. 고속도로 역할</li></ul></li><li>(+) Content provider network. CDN
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-structure-cdn.png alt=IMAGE><ul><li>Google, Microsoft, Akamai</li></ul></li></ul></li></ul><h2 id=4-loss와-delay는-어떻게-발생하는가>4. loss와 delay는 어떻게 발생하는가</h2><ul><li>라우터 buffer에서 packet queue
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-delay.png alt=IMAGE><ul><li>전송 중 패킷 -> delay</li><li>패킷 queueing -> delay</li><li>버퍼 -> loss</li><li>output link capacity.<ul><li>나가는 양보다 들어오는 양이 많으면.</li></ul></li></ul></li></ul><p><img src=https://actumn.github.io/images/kucse-computer-network/introduction-delay-calc.png alt=IMAGE><br>$$ d(nodal) = d(proc) + d(queue) + d(trans) + d(prop) $$</p><ul><li><p>d(proc) : nodal processing</p><ul><li>어느 라우터에 보낼 것인지 판단</li></ul></li><li><p>d(queue) : queueing delay</p><ul><li>버퍼에 쌓여서 전송을 기다리는 시간</li><li>congestion이 있다면 delay up, 없다면 delay down</li></ul></li><li><p>d(trans) : transmission delay</p><ul><li>L: packet length</li><li>R: link bandwidth</li><li>d(trans): L/R</li></ul></li><li><p>d(prop) : propagation delay</p><ul><li>빛의 속도로 전파.</li><li>d: length of physical link</li><li>s: propagation speed (빛의 속도. 2x10^8m/s)</li><li>d(prop): d/s</li><li>d(prop)과 d(trans)는 많이 다르다.</li></ul></li><li><p>Queueing delay</p><ul><li>R: link bandwidth (bps)</li><li>L: packet length (bits)</li><li>a: average packet arrival rate</li><li>La/R ~ 0: avg.queueing delay small</li><li>La/R -> 1: avg.queueing delay large</li><li>La/R > 1: 전송할 수 있는 양보다 더 많이 오고있다. delay infinite.</li></ul></li><li><p>&ldquo;Real&rdquo; Internet delays and routes</p><ul><li>진짜 Internet delay & loss 는?</li><li><code>traceroute</code>: delay 측정. 네트워크 디버깅<ul><li>목적지까지 가는 경로의 모든 라우터에 3개의 패킷을 전송</li><li>3개 보낼때 마다 i번째 라우터가 현재 받은 시간을 보낸다.</li></ul></li></ul></li><li><p>Packet loss
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-delay-packet-loss.png alt=IMAGE></p><ul><li>쌓이다 넘치면 drop.</li></ul></li><li><p>Throughput
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-delay-throughput.png alt=IMAGE></p><ul><li>시작점과 목적지 사이에 단위시간당 처리한 양. rate (bits / time unit)<ul><li>instaneous: 한 순간의 throughput</li><li>average: 평균</li></ul></li><li>R(s) &lt; R(c)<ul><li>R(s) 1초. R(c) 10초 -> 10초</li></ul></li><li>R(s) > R(c)<ul><li>R(s) 10초, R(c) 1초 -> 10초</li></ul></li><li>bottle enck link.<ul><li>bottleneck 용량이 전체 용량.</li><li>bottleneck을 찾아서 해결하는 게 중요하다.</li></ul></li><li>Internet scenario.
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-delay-scenario.png alt=IMAGE><ul><li>Connection 별 end-end throughput은<ul><li>min(R(c), R(s), R/10)</li><li>R(c) 또는 R(s)가 보통 bottleneck.</li></ul></li></ul></li></ul></li></ul><h2 id=5-프로토콜-레이어>5. 프로토콜 레이어</h2><ul><li>네트워크는 복잡하고, 많은 조각들이 존재<ul><li>hosts</li><li>routers</li><li>links of various media</li><li>applications</li><li>protocols</li><li>hardware, software</li><li>어떻게 구성해서 네트워크를 형성하지?<ul><li>복잡한 문제를 해결하기 위해 &ldquo;divide and conquer&rdquo;</li><li>layering, 각 층마다 identification</li><li>&ldquo;change in gate procedure doesn't affect rest of system&rdquo;<br>한 모듈 바꾸는 게 다른 시스템에 영향을 주지 않는다.</li></ul></li></ul></li><li>Internet protocol stack
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-layering-protocol-stack.png alt=IMAGE><ul><li>Application<ul><li>FTP, SMTP,</li></ul></li><li>Transport: 전송계층<ul><li>TCP, UDP</li></ul></li><li>Network: 망계층<ul><li>IP, routing protocols</li></ul></li><li>link<ul><li>이더넷</li></ul></li><li>physical<ul><li>bits &ldquo;on the wire&rdquo;</li></ul></li></ul></li><li>ISO/OSI reference model
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-layering-protocol-osi-reference.png alt=IMAGE><ul><li>presentation: 표현계층<ul><li>암호화, 압축</li><li>machine-specific conventions</li></ul></li><li>session<ul><li>synchronization</li><li>checkpointing: 영화 다운로드, recovery of data exchange</li></ul></li><li>이런건 application에서 구현하자.</li></ul></li><li>Encapsulation / Decapsulation
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-layering-encapsulation.png alt=IMAGE></li></ul><h2 id=6-보안>6. 보안</h2><ul><li>네트워크 보안<ul><li>침입자가 어떻게 공격할 것인가.</li><li>어떻게 방어할 것인가</li><li>어떻게 면역있게 설계할 것인가.</li><li>다시 설계는 안되고 &mldr;<ul><li>block chain.</li><li>단점도 있다.</li></ul></li><li>필요할 때마다 필요한 계층에 security를 고려할 것</li></ul></li><li>Bad guy: 인터넷을 통해 호스트에 malware를 넣었다.<ul><li>virus: 이메일&mldr; 사람이 직접 클릭해야 한다.</li><li>worm: 자가복제로 감염. 수동적으로 또는 자동적으로 수행</li><li>spyware: 패스워드, 크레딧카드,</li><li>botnet: span, DDos</li></ul></li><li>Bad guy: 서버, 네트워크 인프라 공격
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-security-dos.png alt=IMAGE><ul><li>Dos (Denial of Service)<ul><li>타겟을 고르고</li><li>botnet</li><li>타겟에게 패킷을</li></ul></li></ul></li><li>Bad guy: 패킷 스니핑
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-security-packet-sniff.png alt=IMAGE><ul><li>wireshark</li></ul></li><li>Bad guy: fake address 사용
<img src=https://actumn.github.io/images/kucse-computer-network/introduction-security-fake-address.png alt=IMAGE></li></ul><h1 id=chapter-2-application-layer>Chapter 2: Application Layer</h1><ul><li>principle</li><li>web, http</li><li>SMTP, POP3, IMAP</li><li>DNS</li><li>P2P</li><li>Video Streaming, CDN</li><li>TCP, UDP</li></ul><hr><h2 id=1-principle>1. principle</h2><ul><li>Creating a network app<ul><li>엔드시스템에 올라가는 프로그램</li><li>network에서 통신</li><li>network-core device를 위한 소프트웨어를 작성할 필요는 없다.<ul><li>network-core device는 user application을 실행하지 않는다.</li></ul></li></ul></li><li>Client-Server architecture<ul><li>server<ul><li>always-on host</li><li>고정 IP</li><li>데이터센터. 수십개의 논리적 1서버</li></ul></li><li>clients<ul><li>서버와 통신</li><li>붙었다가 끊어졌다가.</li><li>Dynamic IP addresses</li><li>클라이언트끼리 직접 통신 x<ul><li>화상회의 -> 중간에 controller가 있다.</li></ul></li></ul></li></ul></li><li>P2P<ul><li>always-on server가 없다.</li><li>peer가 서버도 되고 클라이언트도 되고.</li><li>self-scalable</li><li>intermittently connected, and change IP addresses<ul><li>복잡한 management</li></ul></li></ul></li><li>process: host에서 실행되는 프로그램<ul><li>동일 호스트에서 2개 이상 프로세스와 통신 - IPC<ul><li>client process: 연결을 맺는다.</li><li>server process: 연결을 기다린다.</li></ul></li></ul></li><li>Addressing processes
<img src=https://actumn.github.io/images/kucse-computer-network/application-principle-sockets.png alt=IMAGE><ul><li>서로 다른 호스트</li><li>클라이언트가 서버를 찾아야 한다. (IP)</li><li>소켓<ul><li>IP를 알아야한다. 32 bit address</li><li>port도 알아야한다. -> TCP/UDP. 80(http), 25(mail)</li></ul></li></ul></li><li>App-layer protocol defines<ul><li>types<ul><li>ex) request, response</li></ul></li><li>message syntax</li><li>message sementics</li><li>rules<ul><li>언제 어떻게 프로세스가 메세지를 전송/수신 할 것인가.</li></ul></li><li>open protocols<ul><li>RFC</li><li>interoperability (상호 운용성)</li><li>ex) HTTP, SMTP</li></ul></li><li>proprietary protocol<ul><li>ex) skype</li></ul></li></ul></li><li>App에서 필요한 transport service?<ul><li>data integrity<ul><li>앱에 따라 100% reliable data transfer를 필요로 한다.</li><li>어떤 앱은 손실이 있어도 괜찮다.</li></ul></li><li>timing<ul><li>앱에 따라 low delay를 요구 (Internet telephony, interactive games)</li></ul></li><li>throughput -> bandwidth<ul><li>multimedia 앱은 throughput 양을 좀 많이 필요</li><li>ftp, email은 좀 기다려도 된다.</li></ul></li><li>security<ul><li>encryption, data integrity, &mldr;</li></ul></li></ul></li></ul><h2 id=2-web-and-http>2. Web and HTTP</h2><ul><li>Web page<ul><li>object로 구성</li><li>object -> HTML, JPEG, Java applet, audio file, &mldr;</li><li>URL로 접근</li></ul></li></ul><pre><code>www.someschool.edu/someDept/pic.gif

host name : www.someschool.edu
path name : /someDept/pic.gif
</code></pre><ul><li>HTTP: hypertext transfer protocol
<img src=https://actumn.github.io/images/kucse-computer-network/application-http-overview.png alt=IMAGE><ul><li>Web의 application layer protocol</li><li>client: browser. request</li><li>server: response. reply</li><li>TCP 사용<ul><li>reliable. 80 port</li><li>client - initiate TCP connection to server</li><li>server - accept TCP connection</li><li>HTTP 메세지 교환</li><li>TCP Connection closed.</li></ul></li><li>statless - request, response<ul><li>어떤 state도 기억하지 않음</li><li>&lt;-> stateful. 복잡하다<ul><li>과거의 상태를 기억</li><li>돌아가는 point (check point), sync.</li><li>관리가 복잡하다</li></ul></li></ul></li></ul></li><li>HTTP connections<ul><li>non-persistent HTTP<ul><li>one object - one connection</li><li>object 보내고 끊고, 보내고 끊고&mldr;</li><li>10 object - 10 connection</li></ul></li><li>persistent HTTP<ul><li>single TCP connection</li></ul></li></ul></li><li>Non-persistent HTTP: response time
<img src=https://actumn.github.io/images/kucse-computer-network/application-http-response-time.png alt=IMAGE><ul><li>RTT (Round Trip Time)</li><li>HTTP response time: 2 RTT + file transmission time</li><li>2 RTT per object</li></ul></li><li>Persistent HTTP<ul><li>server - connection</li><li>subsequent HTTP messages</li><li>1 RTT</li></ul></li><li>HTTP Request messages<ul><li>request, response</li><li>ASCII</li></ul></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>GET /index.html HTTP/1.1\r\n
Host: www-net.cs.umass.edu\r\n
User-Agent: Firefox/3.6.10\r\n
Accept: text/html,application/xhtml+xml\r\n
Accept-Language: en-us,en;q=0.5\r\n
Accept-Encoding: gzip,deflate\r\n
Accept-Charset: ISO-8859-1,utf-8;q=0.7\r\n
Keep-Alive: 115\r\n
Connection: keep-alive\r\n
</code></pre></div><ul><li>general format
<img src=https://actumn.github.io/images/kucse-computer-network/application-http-general-format.png alt=IMAGE></li><li>Uploading form input<ul><li>POST<ul><li>보통 form input을 포함</li><li>input은 모두 body에.</li></ul></li></ul></li><li>Method types<ul><li>HTTP/1.0<ul><li>GET. POST, HEAD</li></ul></li><li>HTTP/1.1<ul><li>GET, POST, HEAD</li><li>PUT: server upload</li><li>DELETE: delete file</li></ul></li></ul></li><li>HTTP response message</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>HTTP/1.1 200 OK\r\n
Date: Sun, 26 Sep 2010 20:09:20 GMT\r\n
Server: Apache/2.0.52 (CentOS)\r\n
Last-Modified: Tue, 30 Oct 2007 17:00:02
GMT\r\n
ETag: &#34;17dc6-a5c-bf716880&#34;\r\n
Accept-Ranges: bytes\r\n
Content-Length: 2652\r\n
Keep-Alive: timeout=10, max=100\r\n
Connection: Keep-Alive\r\n
Content-Type: text/html; charset=ISO-8859-
1\r\n
\r\n
data data data data data ...
</code></pre></div><ul><li>HTTP response status codes<ul><li>200 OK</li><li>301 Moved Permanently</li><li>400 Bad Request</li><li>404 Not Found</li><li>505 HTTP Version Not Supported</li></ul></li><li>User-server state: cookies<ul><li>authorization (뭘 할 수 있나) (유의. authentication - 신분 확인)</li><li>shopping cart</li><li>recommendation</li><li>user session state</li><li>cookies and privacy. 보안문제</li></ul></li><li>Web caches
<img src=https://actumn.github.io/images/kucse-computer-network/application-http-web-caches.png alt=IMAGE><ul><li>있으면 proxy에서 가져온다. (cache)</li><li>(+) bandwidth 절약</li><li>(-) proxy 병목. SPoF</li><li>Why web caching?<ul><li>response time down</li><li>bandwidth / traffic down</li><li>Content provider에게 유리</li></ul></li><li>Proxy<ul><li>client / server 역할</li></ul></li></ul></li><li>Conditional GET
<img src=https://actumn.github.io/images/kucse-computer-network/application-http-conditional-get.png alt=IMAGE><ul><li><code>If-modified-since: &lt;date></code></li></ul></li></ul><h2 id=3-전자-메일>3. 전자 메일</h2><ul><li>Three major components<ul><li>user agents -> 웹브라우저, outlook</li><li>mail server - <code>mail.konuk.ac.kr</code>, <code>gmail.com</code></li><li>SMTP: simple maill transfer protocol
<img src=https://actumn.github.io/images/kucse-computer-network/application-mail-smtp.png alt=IMAGE></li></ul></li><li>User agent<ul><li>&ldquo;mail reader&rdquo;</li><li>composing, editing, reading mail</li></ul></li><li>Mail server<ul><li>mail box</li><li>message queue</li><li>SMTP<ul><li>client: sending mail server</li><li>&ldquo;server&rdquo;: receiving mail server</li></ul></li></ul></li><li>SMTP [RFC 2821]<ul><li>TCP, port 25</li><li>direct transfer</li><li>persistent. 100개 있으면 다 받고 connection을 끊는다.<ul><li>handshaking</li><li>transfer of message</li><li>closure.</li></ul></li><li>command/response interaction (HTTP 처럼)<ul><li>command: ASCII text</li><li>response: status code</li></ul></li><li>시나리오
<img src=https://actumn.github.io/images/kucse-computer-network/application-mail-smtp-scenario.png alt=IMAGE></li><li>SMTP interaction</li></ul></li></ul><pre><code>S: 220 hamburger.edu
C: HELO crepes.fr
S: 250 Hello crepes.fr, pleased to meet you
C: MAIL FROM: &lt;alice@crepes.fr&gt;
S: 250 alice@crepes.fr... Sender ok
C: RCPT TO: &lt;bob@hamburger.edu&gt;
S: 250 bob@hamburger.edu ... Recipient ok
C: DATA
S: 354 Enter mail, end with &quot;.&quot; on a line by itself
C: Do you like ketchup?
C: How about pickles?
C: .
S: 250 Message accepted for delivery
C: QUIT
S:221 hamburger.edu closing connection
</code></pre><ul><li>SMTP와 HTTP 비교<ul><li>HTTP: pull</li><li>SMTP: push. 서버가 먼저 요청</li><li>둘다 ASCII command / response interaction, status code</li></ul></li><li>SMTP: final words<ul><li>persistent connection</li><li>message (header & body) in 7 bit ASCII</li><li>CRLF.CRLF - end of message</li></ul></li><li>Mail message format
<img src=https://actumn.github.io/images/kucse-computer-network/application-mail-message-format.png alt=IMAGE><ul><li>RFC 822<ul><li>TO:</li><li>From:</li><li>Subject:</li><li>SMTP 시스템이 만들어주는 커맨드 FROM, RCPT TO와는 다르다.</li><li>Body: the &ldquo;message&rdquo; . ASCII only. (요즘은 멀티미디어 확장)</li></ul></li></ul></li><li>Maill access protocols
<img src=https://actumn.github.io/images/kucse-computer-network/application-mail-protocols.png alt=IMAGE><ul><li>POP [RFC 1939]. authorization</li><li>IMAP [RFC 1730]. 정교한 메세지 조작.</li></ul></li><li>POP3 protocol
<img src=https://actumn.github.io/images/kucse-computer-network/application-mail-pop3.png alt=IMAGE><ul><li>authorization phase<ul><li>client commands:<ul><li>user</li><li>pass</li></ul></li><li>server<ul><li>+OK</li><li>-ERR</li></ul></li></ul></li><li>transaction phase<ul><li>list: list message numbers</li><li>retr: retrieve message</li><li>dele</li><li>quit</li></ul></li></ul></li><li>POP3 vs IMAP<ul><li>POP3<ul><li>&ldquo;download and delete&rdquo;</li><li>&ldquo;download and keep&rdquo;</li><li>stateless</li></ul></li><li>IMAP<ul><li>mail box에 폴더를 많이, manipulation</li><li>stateful</li></ul></li></ul></li></ul><h2 id=4-dns>4. DNS</h2><ul><li>DNS: domain name system<ul><li>Internet hosts, routers<ul><li>IP address (32 bit). 외우기 어렵다<ul><li>addressing datagram 에 쓰인다.</li></ul></li><li>&ldquo;name&rdquo;<ul><li>ex) <a href=http://www.yahoo.com>www.yahoo.com</a> -> 사람이 쓰는거</li></ul></li></ul></li><li>분산 DB<ul><li>계층적으로</li></ul></li><li>application layer<ul><li>name server와 통신해서 resolve</li><li>application-layer protocols</li><li>network edge</li></ul></li></ul></li><li>DNS services<ul><li>hostnames -> IP address translation. 주요한 기능</li><li>host aliasing<ul><li>canonical -> 정식이름, aliase -> 별명</li></ul></li><li>mail server aliasing</li><li>load distribution<ul><li>replicated web servers (google.com)<br>많은 IP address가 있는데, 딱 1개의 name</li></ul></li><li>Why not centralize?<ul><li>Single point of failure</li><li>traffic volume -> 호스트가 무진장 많을거고, 요청도 무진장 많을거고</li><li>distant centralized database. 요청자와의 거리 고려</li><li>maintance</li></ul></li></ul></li><li>DNS: distributed hierarchical database
<img src=https://actumn.github.io/images/kucse-computer-network/application-dns-hierarchical.png alt=IMAGE><ul><li>client -> <a href=http://www.amazon.com>www.amazon.com</a><ul><li>client queries <code>root</code> server to find <code>.com</code> DNS</li><li>client queries <code>.com</code> DNS server to get <code>amazon.com</code> DNS</li><li>client queries <code>amazon.com</code> DNS server to get IP address for <a href=http://www.amazon.com>www.amazon.com</a></li></ul></li><li>13개의 root name server<ul><li>UDP 패킷사이즈&mldr; 13이 maximum</li><li>복사판은 수십개</li></ul></li><li>top-level domain (TLD) servers<ul><li>CCTLD: <code>.uk</code>, <code>.fr</code>, <code>.ca</code>, <code>.jp</code></li><li>gTLD: <code>.com</code>, <code>.org</code>, <code>.net</code></li><li><code>Network solutions</code>이 .com을 관리한다</li><li><code>Educase</code>가 .edu를 관리한다</li></ul></li><li>authoritative name server<ul><li>수많은 host.<ul><li><code>engineering.konkuk.ac.kr</code></li><li><code>cse.konkuk.ac.kr</code></li></ul></li><li>organization이 관리한다.</li><li>등록해놓은 authoritative name server.<ul><li><code>ns.konkuk.ac.kr</code></li><li>이를 외부에 알린다.</li></ul></li></ul></li></ul></li><li>Local DNS name server<ul><li>내부적으로도 운용할 수 일다. (hierarchy를 엄격히 지키지 않는다)</li><li>각 지역 ISP(residential, company, university)는 1개 갖고 있다<ul><li>&ldquo;default name server&rdquo;</li></ul></li><li>local DNS Server에 제일 처음으로 물어본다<ul><li>local cache를 한다. (TTL 존재, 지나면 expire)</li><li>proxy로 작요</li></ul></li></ul></li><li>DNS name resolution example<ul><li>iterated
<img src=https://actumn.github.io/images/kucse-computer-network/application-dns-resolve-iterated.png alt=IMAGE><ul><li>처음에 contact 하는 DNS는 local DNS server</li><li>많이 쓰인다.</li></ul></li><li>recursive query
<img src=https://actumn.github.io/images/kucse-computer-network/application-dns-resolve-recursive.png alt=IMAGE><ul><li>root에 큰 load가 걸린다.</li></ul></li></ul></li><li>DNS caching, updating reords<ul><li>cache timeout after some time (TTL)</li><li>TLD는 local name server에 캐시되어 있다. root를 방문할 필요가 잘 없다.</li><li>호스트 IP가 바뀌어도 TTL expire까지는 모른다.</li></ul></li><li>DNS records<ul><li>DNS: store resource records (RR)</li><li>RR Format: (name, value, type, ttl)</li><li>type=A:<ul><li>(<a href=http://www.konkuk.ac.kr,>www.konkuk.ac.kr,</a> 203.252.180.1, A, 24)</li><li>name: hostname</li><li>value: IP address</li></ul></li><li>type=NS: name server<ul><li>(konkuk.ac.kr, ns.konkuk.ac.kr, ns, 24)</li><li>name: domain</li><li>value: host name</li></ul></li><li>type=CNAME:<ul><li>(<a href=http://www.konkuk.ac.kr,>www.konkuk.ac.kr,</a> web.konkuk.ac.kr, CNAME, 24)</li><li>name is alias for some real name</li></ul></li><li>type=MX: mail server<ul><li>(konkuk.ac.kr, mail.konkuk.ac.kr, MX, 24)</li></ul></li></ul></li><li>DNS protocol, messages
<img src=https://actumn.github.io/images/kucse-computer-network/application-dns-message.png alt=IMAGE><ul><li>query and reply</li><li>identification</li><li>flags<ul><li>query or reply</li><li>recursion</li><li>recursion available</li><li>reply is authoritative</li></ul></li></ul></li><li>Inserting records into DNS<ul><li>ex) new startup &ldquo;Network Utopia&rdquo;<ul><li>DNS registrar에 <code>networkutopia.com</code> 등록<ul><li>2개의 RR이 등록된다.<ul><li>(networkutopia.com, dns1.networkutopia.com, NS)</li><li>(dns1.networkutopia.com, 212.212.212.1, A)</li></ul></li></ul></li><li>type A: <code>www.networkuptopia.com</code></li><li>type MX: <code>mail.networkuptopia.com</code></li><li>더 필요하다면 authoritative server에 등록</li></ul></li></ul></li><li>Attacking DNS<ul><li>DDoS attacks<ul><li>root server</li><li>많이 쓰는 TLD는 캐싱된다.</li><li>많이 쓰는 TLD가 더 위험하다.</li></ul></li><li>redirect attacks<ul><li>main-in-middle<ul><li>가로채서 변환해서 query</li><li>가로채서 reply</li></ul></li><li>이상한 사이트에 접속되고, 크레딧 카드를 훔쳐간다..</li></ul></li><li>exploit DNS for DDoS<ul><li>spoofed source</li></ul></li><li>DNS는 공격을 많이받는다.</li></ul></li></ul><h2 id=5-p2p-application>5. P2P application</h2><ul><li>Pure P2P architecture<ul><li>no always-on server.<ul><li>항상 켜져있는 서버는 없다.</li><li>어떤 node건 서버가 된다.</li></ul></li><li>arbitrary end system directly communicate<ul><li>임의의 end system이 통신이 가능하다.</li></ul></li><li>peers are intermittently connected<ul><li>연결되었다가 끊어졌다가. IP가 바뀔수도 있다.</li></ul></li><li>examples<ul><li>BitTorrent -> file distribution</li><li>KanKan -> Streaming</li><li>Skype -> VoIP</li></ul></li></ul></li><li>File distribution: client-server vs P2P
<img src=https://actumn.github.io/images/kucse-computer-network/application-p2p-file-distribution.png alt=IMAGE><ul><li>size F file을 1서버에서 N개의 peer에게 보낼 때 시간이 얼마나 걸릴까?</li><li>client-server<ul><li>server 전송<ul><li>one copy: F/u(s)</li><li>N copies: N * F / u(s)</li></ul></li><li>client<ul><li>d(min): min client download rate</li><li>F/d(min)</li></ul></li><li>N에 비례하여 느려진다.
$$ D(c~s) >= max(N*F/u(s), F/d(min) $$</li></ul></li><li>P2P<ul><li>처음 one copy: F/u(s)</li><li>min client download: F/d(min)</li><li>upload: NF/(u)</li><li>N에 비례하여 업로드도 늘어난다.
$$ D(P2P) >= max{F/u(s), F/d(min), N*F/(u(s)+\sum_{i=1}^nu(i))} $$
<img src=https://actumn.github.io/images/kucse-computer-network/application-p2p-file-graph.png alt=IMAGE></li></ul></li></ul></li><li>P2P file distribution: BitTorrent
<img src=https://actumn.github.io/images/kucse-computer-network/application-p2p-torrent.png alt=IMAGE><ul><li>파일을 256kb Chunk로 나눈다.<ul><li>chunk단위로 file을 공유 (send/receive)</li></ul></li><li>토렌트에 참여하는 peer<ul><li>처음에는 chunk가 없지만 시간이 지나면서 자기가 없는 chunk를 받는다.</li><li>tracker를 통해서 neighbor를 찾고, chunk를 upload/download</li><li>churn. 피어가 올 수도, 떠날 수도</li><li>peer가 전체 파일을 받으면<ul><li>(selfishishly) 떠나거나</li><li>(altruistically) 공유를 위해 토렌트에 남거나</li></ul></li></ul></li></ul></li><li>BitTorrent: requesting, sending file chunks<ul><li>requesting chunks<ul><li>주어진 시간에 다른 피어가 다른 파일 chunkset을 가지고 있다.</li><li>주기적으로, Alice가 각 peer에게 chunk를 요청</li><li>요청은 rarest first. 희귀한거 먼저.</li></ul></li><li>sending chunks: tit-for-tat<ul><li>chunk를 보낼 땐 아무한테나 주는게 아닌, 자신한테 가장 많이준 4개 peer에게 전송 (10초마다 바뀜)</li><li>30초마다 임의의 다른 peer를 고르고 chunk를 보낸다.</li></ul></li><li>줄때와 받을 때의 policy가 다르다</li></ul></li></ul><h2 id=6-video-streaming-and-cdn>6. Video Streaming and CDN</h2><ul><li>Video streaming<ul><li>Youtube, Netflix, hulu, kankan, akamai</li><li>Video traffic이 점점 늘어난다.</li><li>코로나때문에 더 각광</li><li>zoom, skype, teams, hangout</li><li>challenge: 10억명의 유저를 scale<ul><li>single-mega-video 서버는 불가능</li><li>사용자측에선 1서버라고 생각하게 된다. 1 access point</li></ul></li><li>challenge: heterogeneity.<ul><li>사용자별 bandwidth가 다르다.</li><li>wifi, LAN &mldr;</li></ul></li><li>Solution: distributed, application-level infrastructure</li></ul></li><li>Multimedia: Video<ul><li>가장 bandwidth를 많이 먹는다.</li><li>해상도도 많다. 4K, 8K, Full HD, standard HD, &mldr;</li><li>순차적 이미지 display, 24 images / sec</li><li>하나하나가 digial image. 1920x1080x24&mldr;</li><li>압축을 해야한다. lossless, lossy, &mldr;</li><li>coding: image 내, image 간 중복제거<ul><li>spatial: 이미지 내 같은 픽셀, RLE -> 1920b</li><li>temporal: it1과 it2 이미지의 차이만 저장 (압축에 유리)</li></ul></li><li>CBR (constant bit ratio)<ul><li>단위시간당 encoding율이 동일 (정지화면이건 뛰는 화면이건)</li><li>bandwidth가 10Mbps로 보장이 되면 CBR해도 괜찮다.</li></ul></li><li>VBR (variable bit rate)<ul><li>단위시간당 encoding율이 가변적 (정지화면이면 압축률 up)</li></ul></li><li>examples.<ul><li>MPEG1 -> CBR. 1.5Mbps</li><li>MPEG2 -> VBR.</li><li>MPEG4 -> 인터넷에서 많이 쓰임</li></ul></li></ul></li><li>Streaming stored video
<img src=https://actumn.github.io/images/kucse-computer-network/application-video-streaming.png alt=IMAGE></li><li>DASH<ul><li>Dynamic Adaptive Streaming over HTTP</li><li>server<ul><li>video file을 multiple chunk로 나눈다.</li><li>각 chunk는 다른 rate로 인코딩</li><li>manifest file. 다른 chunk의 URL 제공.<ul><li>사용자가 원할때마다 여기서 찾아가라. => 해상도 변경 등</li></ul></li></ul></li><li>client<ul><li>주기적으로 server-to-client bandwidth 측정</li><li>consulting manifest, 한 순간에 한 chunk를 요청<ul><li>현재 bandwidth에 따라서 알맞은 chunk를 갖고 온다.</li><li>시간마다 갖고 오는 coding rate가 달라질 수 있다.</li></ul></li><li>&ldquo;Intelligence&rdquo; at client. 클라이언트가 결정한다.<ul><li>클라이언트가 언제 청할지</li><li>어떤 encoding rate를 요청할지</li><li>어디서 가져올 것인지. (bandwidth에 따라 manifest)</li></ul></li></ul></li></ul></li><li>Content distribution networks<ul><li>서버가 분산, 복사판이 많이 있다</li><li>클라이언트는 가장 가까운 곳에서 가져온다</li><li>challenge: 수십만 동시 유저에게 어떻게 스트리밍 하지? 어떻게 분산, 배분하지?</li><li>Option 1: single, large &ldquo;mega-server&rdquo;<ul><li>single point of failure</li><li>point of network congestion</li><li>long path to distant clients (미국 서버 - 한국 클라이언트)</li><li>multiple copies of video sent over outgong link (반복적으로 같은 영상 copy)</li></ul></li><li>Option 2: CDN<ul><li>여러 지리적 복사판을 만들자.</li><li>enter deep: access network에 CDN 서버를 두자.<ul><li>사용자에게 가까이</li><li>used by Akamai</li></ul></li><li>bring home: access 망에 가까이 있는 전화국에 CDN 서버를 둔다.<ul><li>access 망보단 느리다.</li><li>used by Limelight</li></ul></li></ul></li><li>CDN: CDN노드에 컨텐츠 카피를 저장해둔다.</li><li>Subscriber는 가까운 곳에서 가져온다.
<img src=https://actumn.github.io/images/kucse-computer-network/application-video-cdn-path.png alt=IMAGE></li><li>&ldquo;OTT&rdquo;: over the top. OTT 서비스.<ul><li>TV만 볼게 아니라 셋탑박스로 보자.</li></ul></li><li>어떤 원리로 가장 가까운 서버를 찾아주는가?
<img src=https://actumn.github.io/images/kucse-computer-network/application-video-cdn-example.png alt=IMAGE></li></ul></li></ul><h2 id=7-socket-programming>7. Socket programming</h2><p><img src=https://actumn.github.io/images/kucse-computer-network/application-socket-overview.png alt=IMAGE></p><ul><li>socket: door between application process end-end transport protocol.<ul><li>UDP: unreliable datagram.</li><li>TCP: reliable, byte stream-oriented</li></ul></li><li>UDP<ul><li>&ldquo;connection"이 없다</li><li>no handshaking</li><li>sender (client) IP port</li><li>receiver (server) IP port</li><li>데이터 손실, 순서가 바뀔 가능성</li><li>Application viewpoint<ul><li>unreliable transfer. 신뢰성 없는 서비스</li></ul></li><li>Interaction
<img src=https://actumn.github.io/images/kucse-computer-network/application-socket-udp-interaction.png alt=IMAGE></li></ul></li><li>TCP<ul><li>client must contact server<ul><li>server는 먼저 실행되어야 한다.</li><li>server는 socket을 만들어둬야 한다.</li></ul></li><li>client<ul><li>TCP socket을 만들고 IP, port specify</li><li>client가 socket을 만들때 client TCP - server TCP connection 성립</li><li>client가 오면 connection. server TCP는 socket을 만들고 특정 client와 통신</li></ul></li><li>application view point<ul><li>reliable</li><li>in-order byte-stream</li></ul></li><li>Interaction
<img src=https://actumn.github.io/images/kucse-computer-network/application-socket-tcp-interaction.png alt=IMAGE></li></ul></li></ul><h1 id=chapter-3-transport-layer>Chapter 3: Transport Layer</h1><ul><li>transport-layer services</li><li>Multiplexing, demultiplexing (TCP, UDP)</li><li>reliable data transfer (TCP)</li><li>Flow control. buffer가 넘치지 않도록 받을 수 있을 만큼만 보낸다.</li><li>Congestion Control. 패킷 네트워크 성능 저하 방지.</li></ul><hr><h2 id=1-transport-layer-services>1. transport-layer services</h2><ul><li>Transport services and protocol<ul><li>logical end-to-end communication 제공. (physical은 복잡하다)</li><li>긴 message를 짤라서 보낸다. (segment)</li><li>reassemble. segment를 다시 모은다.</li><li>TCP, UDP, SCTP</li></ul></li><li>Transport vs Network layer<ul><li>host는 1개 (ip), 프로세스는 여러개 (port)<ul><li>host까지 찾아가는 network layer</li><li>process까지 찾아가는 transport layer.</li></ul></li></ul></li><li>Internet transport-layer protocol<ul><li>reliable, in-order delivery (TCP)<ul><li>congestion control</li><li>flow control</li><li>connection setup</li></ul></li><li>unreliable, unordered (UDP)<ul><li>IP에서 그닥 더 하는건 없다.</li></ul></li><li>not availble<ul><li>delay guarantee</li><li>bandwidth guarantee</li></ul></li></ul></li></ul><h2 id=2-multiplexing--demultiplexing>2. Multiplexing / demultiplexing</h2><p><img src=https://actumn.github.io/images/kucse-computer-network/transport-multiplexing.png alt=IMAGE></p><ul><li>Connection을 2개 이상 만든다.<ul><li>multiplexing.<ul><li>전송할 때 transport header 추가 (나중에 demultiplexing할때 까볼 header)</li></ul></li><li>demultiplexing<ul><li>들어온 패킷을 까서 header info를 보고 올바른 socket에 데이터 전달
<img src=https://actumn.github.io/images/kucse-computer-network/transport-multiplexing-demultiplex.png alt=IMAGE></li></ul></li></ul></li></ul><h2 id=3-udp>3. UDP</h2><ul><li>UDP: User Datagram Protocol [RFC 768]<ul><li>&ldquo;no frills&rdquo;. IP에서 더 해주는 게 거의 없다.</li><li>&ldquo;best effort&rdquo;. 최선을 다하겠다. guarantee 는 못하겠다.<ul><li>lost</li><li>out of order</li></ul></li><li>connectionless<ul><li>no handshaking. 바로 보낸다.</li><li>UDP segment가 독자적으로 간다. connection 다라 가는게 없다.</li></ul></li><li>UDP use<ul><li>streaming multimedia apps.<ul><li>loss tolerant. 패킷이 없어져도 큰 문제는 아니다</li><li>rate sensitive. 대역폭 guarantee 필요</li></ul></li><li>DNS</li><li>SNMP 망관리프로토콜 (Simple Network Management Protocol)</li></ul></li><li>UDP 위의 reliable transfer<ul><li>application layer에서 reliability</li><li>application-specific error handling</li></ul></li></ul></li><li>UDP segment header
<img src=https://actumn.github.io/images/kucse-computer-network/transport-udp-segment.png alt=IMAGE><ul><li>no connection establishment (connection은 delay 가능성이 있으니)</li><li>simple: no connection state at sender, receiver</li><li>small header size (TCP 에 비해서)</li><li>no congestion control. (빨리 보낼 수 있는대로 보낸다.)</li></ul></li><li>UDP checksum<ul><li>계산이 빨라야한다</li><li>sender<ul><li>segment content/header를 16비트 단위로 짤라서 계산</li><li>checksum: 더해서 1의 보수를 취한다.</li><li>그리고 header에 put.</li></ul></li><li>receiver<ul><li>received segment에서 checksum 계산.</li><li>비교해서 값이 다르면 error<ul><li>DNS -> 에러처리</li><li>VoIP -> 에러가 없어도 크게 지장이 없다.</li></ul></li></ul></li><li>example
<img src=https://actumn.github.io/images/kucse-computer-network/transport-udp-checksum-example.png alt=IMAGE></li></ul></li></ul><h2 id=4-principles-of-reliable-data-transfer>4. Principles of reliable data transfer</h2><p><img src=https://actumn.github.io/images/kucse-computer-network/transport-reliable-implement.png alt=IMAGE></p><ul><li>sender가 주는 그대로 receiver가 받아야한다.<ul><li>rdt_send()</li><li>udt_send()</li><li>rdt_rcv()</li><li>deliver_data()</li></ul></li><li>Finite State Machine (FSM)<ul><li>rdt 1.0: reliable transfer over a reliable channel<ul><li>underlying channel은 완벽히 믿을 수 있다.<ul><li>no bit errors</li><li>no loss of packets
<img src=https://actumn.github.io/images/kucse-computer-network/transport-reliable-rdt1.0.png alt=IMAGE></li></ul></li></ul></li><li>rdt 2.0: Channel with bit errors<ul><li>reliable channel이 아니다</li><li>에러 발생 가능성<ul><li>checksum으로 에러탐지</li><li>how to recover?<ul><li>다시 보내자.</li></ul></li><li>ACK: 에러 없음</li><li>NAK: 에러 있음
<img src=https://actumn.github.io/images/kucse-computer-network/transport-reliable-rdt2.0.png alt=IMAGE></li></ul></li><li>Fatal flow<ul><li>ACK, NAK가 오는 것도 에러가 있을 수 있다</li><li>아니면 ACK duplicate</li><li>각 패킷에 seq number를 붙이자</li><li>Stop and Wait 프로토콜<ul><li>sender가 1 패킷을 보내고 receiver response를 기다린다.</li></ul></li><li>ACK -> 다음꺼</li><li>NAK -> 지금꺼 다시</li></ul></li></ul></li><li>rdt 2.1: sender
<img src=https://actumn.github.io/images/kucse-computer-network/transport-reliable-rdt2.1-sender.png alt=IMAGE></li><li>rdt 2.1: receiver
<img src=https://actumn.github.io/images/kucse-computer-network/transport-reliable-rdt2.1-receiver.png alt=IMAGE></li><li>rdt 2.2: NAK-free protocol<ul><li>보통 ACK만 쓴다.
<img src=https://actumn.github.io/images/kucse-computer-network/transport-reliable-rdt2.2.png alt=IMAGE></li></ul></li></ul></li></ul></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small"></span><br><a class="tag tag--primary tag--small" href=https://actumn.github.io/tags/lecture/>lecture</a>
<a class="tag tag--primary tag--small" href=https://actumn.github.io/tags/computer-science/>computer science</a>
<a class="tag tag--primary tag--small" href=https://actumn.github.io/tags/computer-network/>computer network</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/04/%ED%98%91%EB%8F%99-%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-1/ data-tooltip="협동 분산 시스템 (1)"><i class="fa fa-angle-left"></i><span class="hide-xs hide-sm text-small icon-ml"></span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/03/openjdk-awt-error/ data-tooltip="OpenJDK Awt Error"><span class="hide-xs hide-sm text-small icon-mr"></span><i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions><i class="fa fa-share-alt"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread><i class="fa fa-comment-o"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#><i class="fa fa-list"></i></a></li></ul></div><div id=disqus_thread><noscript>Please enable JavaScript to view the <a href=//disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2021 SunMyeong Lee.</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=1><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/04/%ED%98%91%EB%8F%99-%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-1/ data-tooltip="협동 분산 시스템 (1)"><i class="fa fa-angle-left"></i><span class="hide-xs hide-sm text-small icon-ml"></span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/03/openjdk-awt-error/ data-tooltip="OpenJDK Awt Error"><span class="hide-xs hide-sm text-small icon-mr"></span><i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions><i class="fa fa-share-alt"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread><i class="fa fa-comment-o"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#><i class="fa fa-list"></i></a></li></ul></div></div><div id=share-options-bar class=share-options-bar data-behavior=1><i id=btn-close-shareoptions class="fa fa-close"></i><ul class=share-options></ul></div><div id=share-options-mask class=share-options-mask></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-remove"></i></div><img id=about-card-picture src="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=110" alt><h4 id=about-card-name>SunMyeong Lee</h4><div id=about-card-bio>I love <em>language learning</em>, <em>development</em>, <em>open source</em></div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Student</div><div id=about-card-location><i class="fa fa-map-marker"></i><br>Seoul, Korea</div></div></div><div id=cover style=background-image:url(https://actumn.github.io/images/cover-v1.2.0.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin=anonymous></script><script src=https://actumn.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js></script><script lang=javascript>window.onload=updateMinWidth;window.onresize=updateMinWidth;document.getElementById("sidebar").addEventListener("transitionend",updateMinWidth);function updateMinWidth(){var sidebar=document.getElementById("sidebar");var main=document.getElementById("main");main.style.minWidth="";var w1=getComputedStyle(main).getPropertyValue("min-width");var w2=getComputedStyle(sidebar).getPropertyValue("width");var w3=getComputedStyle(sidebar).getPropertyValue("left");main.style.minWidth=`calc(${w1} - ${w2} - ${w3})`;}</script><script>$(document).ready(function(){hljs.configure({classPrefix:'',useBR:false});$('pre.code-highlight > code, pre > code').each(function(i,block){if(!$(this).hasClass('codeblock')){$(this).addClass('codeblock');}
hljs.highlightBlock(block);});});</script><script>var disqus_config=function(){this.page.url='https:\/\/actumn.github.io\/2020\/04\/computer-network-1\/';this.page.identifier='\/2020\/04\/computer-network-1\/'};(function(){if(window.location.hostname=="localhost"){return;}
var d=document,s=d.createElement('script');var disqus_shortname='hugo-tranquilpeak-theme';s.src='//'+disqus_shortname+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin=anonymous></script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
      CommonHTML: { linebreaks: { automatic: true } },
      tex2jax: { inlineMath: [ ['$', '$'], ['\\(','\\)'] ], displayMath: [ ['$$','$$'], ['\\[', '\\]'] ], processEscapes: false },
      messageStyle: 'none'
    });
  </script></body></html>