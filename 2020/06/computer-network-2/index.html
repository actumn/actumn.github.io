<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.62.2 with theme Tranquilpeak 0.4.7-BETA"><meta name=author content="SunMyeong Lee"><meta name=keywords content="tech"><meta name=description content="건국대학교 컴퓨터네트워크 강의노트 2
Computer Networking: A Top down Approach"><meta property="og:description" content="건국대학교 컴퓨터네트워크 강의노트 2
Computer Networking: A Top down Approach"><meta property="og:type" content="article"><meta property="og:title" content="Computer Network (2)"><meta name=twitter:title content="Computer Network (2)"><meta property="og:url" content="https://actumn.github.io/2020/06/computer-network-2/"><meta property="twitter:url" content="https://actumn.github.io/2020/06/computer-network-2/"><meta property="og:site_name" content="Actumn (SunMyeong Lee)"><meta property="og:description" content="건국대학교 컴퓨터네트워크 강의노트 2
Computer Networking: A Top down Approach"><meta name=twitter:description content="건국대학교 컴퓨터네트워크 강의노트 2
Computer Networking: A Top down Approach"><meta property="og:locale" content="ko-kr"><meta property="article:published_time" content="2020-06-19T17:58:01"><meta property="article:modified_time" content="2020-06-19T17:58:01"><meta property="article:section" content="Computer Science"><meta property="article:tag" content="lecture"><meta property="article:tag" content="computer science"><meta property="article:tag" content="computer network"><meta name=twitter:card content="summary"><meta property="og:image" content="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=640"><meta property="twitter:image" content="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=640"><title>Computer Network (2)</title><link rel=icon href=https://actumn.github.io/favicon.png><link rel=canonical href=https://actumn.github.io/2020/06/computer-network-2/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin=anonymous><link rel=stylesheet href=https://actumn.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css></head><body><div id=blog><header id=header data-behavior=1><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://actumn.github.io/>Actumn (SunMyeong Lee)</a></div><a class=header-right-picture href=https://actumn.github.io/#about><img class=header-picture src="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=90" alt></a></header><nav id=sidebar data-behavior=1><div class=sidebar-container><div class=sidebar-profile><a href=https://actumn.github.io/#about><img class=sidebar-profile-picture src="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=110" alt></a><h4 class=sidebar-profile-name>SunMyeong Lee</h4><h5 class=sidebar-profile-bio>I love <em>language learning</em>, <em>development</em>, <em>open source</em></h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/><i class="sidebar-button-icon fa fa-lg fa-home"></i><span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/categories><i class="sidebar-button-icon fa fa-lg fa-bookmark"></i><span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/tags><i class="sidebar-button-icon fa fa-lg fa-tags"></i><span class=sidebar-button-desc>Tags</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/archives><i class="sidebar-button-icon fa fa-lg fa-archive"></i><span class=sidebar-button-desc>Archives</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://actumn.github.io/#about><i class="sidebar-button-icon fa fa-lg fa-question"></i><span class=sidebar-button-desc>About</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/actumn target=_blank rel=noopener><i class="sidebar-button-icon fa fa-lg fa-github"></i><span class=sidebar-button-desc>GitHub</span></a></li></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=1 class=hasCoverMetaIn><article class=post itemscope itemtype=http://schema.org/BlogPosting><div class="post-header main-content-wrap text-left"><h1 class=post-title itemprop=headline>Computer Network (2)</h1><div class="postShorten-meta post-meta"><time itemprop=datePublished datetime=2020-06-19T17:58:01+09:00>19, 2020</time>
<span></span><a class=category-link href=https://actumn.github.io/categories/computer-science>Computer Science</a></div></div><div class="post-content markdown" itemprop=articleBody><div class=main-content-wrap><p>건국대학교 컴퓨터네트워크 강의노트 2<br>Computer Networking: A Top down Approach</p><h1 id=chapter-3-transport-layer-contd>Chapter 3: Transport Layer (Cont'd)</h1><ul><li><p>Finite State Machine (FSM)</p><ul><li>rdt 3.0: Timing<ul><li>sender가 ACK를 기다리는데, 어느정도 기다려도 오지 않으면 timeout</li><li>reasonable timeout</li><li>ACK가 그냥 delay 되는 거라면 retransmission은 중복. seq가 있어서 receiverㅏ 처리
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-reliable-rdt3.0.png alt=IMAGE>
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-reliable-rdt3.0-action1.png alt=IMAGE>
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-reliable-rdt3.0-action2.png alt=IMAGE></li><li>Performance of rdt<ul><li>동작은 좋은데 성능이 구리다</li><li>ex) 1Gbpgs link, 15ms prop delay, 8000bit packet
$$ D(trans) = L / R = 8 microsecs $$
$$ U(sender) = (L / R) / (RTT + L / R) = 0.008 / 30.008 = 0.00027 $$
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-reliable-rdt3.0-stop-and-wait.png alt=IMAGE></li><li>점유율이 0.00027. bandwidth 낭비. RTT동안 전송이 없으니까.</li></ul></li></ul></li></ul></li><li><p>Pipelined protocols.</p><ul><li><p>병렬로 여러개 보낸다. buffer가 여러개 필요하다</p><ul><li>go-back-N</li><li>Selective Repeat</li></ul></li><li><p>Pipelining: increased utilization
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-pipelining-utilization.png alt=IMAGE>
$$ U(sender) = (3L / R) / (RTT + L / R) = 0.024 / 30.008 = 0.00081 $$</p><ul><li>3배 좋아짐.</li></ul></li><li><p>Go-back-N</p><ul><li>n개: window size. [0 ~ n-1]</li><li>ack없이 n개까지 보낸다.</li><li><strong>Cummulative ack</strong><ul><li>1, 2, 3, 4 있으면 4만 ack.</li></ul></li><li>가장 처음 패킷 timer 측정
ack</li></ul></li><li><p>Selective Repeat</p><ul><li>ack없이 n개까지 보낸다.</li><li><strong>Inidividual ack</strong><ul><li>1, 3 패킷마다 개별적 ack</li></ul></li><li>매 패킷 timer 측정</li></ul></li></ul></li><li><p>Go-Back-N: sender</p><ul><li>sender도 reciever도 window 를 운영.
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-gbn-sender-window.png alt=IMAGE></li><li>Sliding window: ACK를 받을때 마다 window가 움직인다.</li><li>duplicate ACK 가능성.</li><li>제일 오래된 패킷 기준 timeout. 다 다시 보낸다.</li><li>sender extended FSM</li><li>receiver extended FSM<ul><li>ACK-only: 가장 큰거</li><li>out-of-order pkt:<ul><li>discard: no receiver buffering</li><li>re-ACK: seq 가장 높은거.</li></ul></li></ul></li><li>GBN in action
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-gbn-action.png alt=IMAGE><ul><li>3, 4, 5 잘 갔는데 다시보낸다. 조금 비효율적.</li></ul></li></ul></li><li><p>Selective repeat</p><ul><li>GBN은 timeout시 다시보내는 패킷이 많다. (순서가 바뀌어오는거 다 버린다.)</li><li>error난 packet만 재전송</li><li>receiver: individually ack<ul><li>매 패킷마다 timer</li></ul></li><li>window
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-selectrepeat-window.png alt=IMAGE><ul><li>sedner<ul><li>데이터 available window, 패킷 전송</li><li>timeout: 에러난 패킷만 재전송</li><li>ACK<ul><li>나머지는 놔둔다</li></ul></li></ul></li></ul></li><li>Select repeat in action
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-selectrepeat-action.png alt=IMAGE></li><li>단점<ul><li>패킷마다 timer</li><li>buffer management</li><li>딜레마<ul><li>윈도우 사이즈가 충분히 커야한다.</li></ul></li></ul></li></ul></li></ul><h2 id=5-tcp>5. TCP</h2><p>프로토콜이 제법 복잡하다.</p><ul><li><p>Overview</p><ul><li>point-to-point: 1 sender - 1 receiver</li><li>reliable, in-order-byte<ul><li>시간이 좀 걸린다.</li><li>bandwidth 보장 x</li></ul></li><li>pipelined (window size N)<ul><li>TCP congestion / flow control</li></ul></li><li>full duplex data<ul><li>양방향 통신</li><li>MSS: maximum segment size. 패킷 최대 길이 2^16</li></ul></li><li>Connection-ordiented<ul><li>handshaking 한다.</li></ul></li><li>flow controlled</li></ul></li><li><p>TCP segment structure
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-segment.png alt=IMAGE></p><ul><li>총 크기가 TCP는 20 bytes, UDP는 8 bytes. 옵션이 있으면 더 길다.</li><li>sequence number: 0 ~ 2^31-1</li><li>U: 급하다</li><li>A: ACK only
: P: Push. buffer가 차지 않았다.</li><li>R: RST. 비정상종료</li><li>S: SYN</li><li>F: FIN</li><li>receive window: window size N은 가변적.<ul><li>매 윈도우 size는 0 ~ 2^16-1</li><li>3 -> 3만 넘치지 않게 보내라</li><li>=> flow/congestion control</li></ul></li><li>urg data pointer: urgent data 위치</li></ul></li><li><p>TCP seg, numbers, ACKS</p><ul><li>Sequence numbers<ul><li>segment data의 첫번째 byte number</li><li>첫번째 패킷: 1, length 1024, MSS</li><li>두번째 패킷: 1025</li></ul></li><li>acknowledgements<ul><li>cumulative ACK<ul><li>첫번째 패킷 SEQ 1, MSS 1024 => ACK 1025</li><li>다음 SEQ 1025를 기대한다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-seqack.png alt=IMAGE></li></ul></li></ul></li></ul></li><li><p>TCP round trip time, timeout</p><ul><li>timeout이 RTT보다는 커야지<ul><li>그런데 RTT는 유동적</li><li>too short: 불필요한 재전송</li><li>too long: slow reaction</li></ul></li><li>RTT를 어떻게 재지?<ul><li>sampleRTT: 정상적인 패킷 RTT 계산. 최근 몇개 평균
$$ EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT $$s<ul><li>보통 a = 0.125</li></ul></li><li>timeout interval: EstimatedRTT + &ldquo;safety margin&rdquo;<ul><li>EstimatedRTT 변동이 컸다면 -> safety margin도 크게
$$ DevRTT = (1-b) * DevRTT + b * (SampleRTT - EstimatedRTT) $$</li><li>보통 b = 0.25
$$ TimeoutInterval = EstimatedRTT + 4*DevRTT $$</li></ul></li></ul></li></ul></li><li><p>Reliable Data Transfer</p><ul><li><p>RDT services</p><ul><li>pipelined segments</li><li>culmulative acks</li><li>signle transmission timer</li></ul></li><li><p>retransmission triggered</p><ul><li>timeout events</li><li>duplicate acks</li></ul></li><li><p>TCP sender events</p><ul><li>app에서 데이터 전송하려 할 때<ul><li>segment를 seq로 만든다.</li><li>seq -> byte-stream. 첫번째 byte의 byte number</li><li>timer -> oldest unacked segment 기준</li><li>expiration interval: <code>TimeoutInterval</code></li></ul></li></ul></li><li><p>timeout</p><ul><li>Retransmission</li><li>Go-Back-N 이니까 oldest부터 다시 보낸다.</li></ul></li><li><p>ack received</p><ul><li>window sliding</li><li>timer restart</li></ul></li><li><p>TCP sender</p></li><li><p>TCP retransmission scenarios
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-retransmission.png alt=IMAGE>
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-retransmission-2.png alt=IMAGE></p></li><li><p>TCP fast transmit</p><ul><li>time-out period가 상대적으로 길다</li><li>duplicate ACK가 쌓이면 transmit</li><li>&ldquo;triple duplicate ACK&rdquo; => resend unacked segment with smallest seq #
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-fastretransmit.png alt=IMAGE></li></ul></li></ul></li><li><p>TCP Flow control
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-flowcontrol.png alt=IMAGE></p><ul><li>(receiver control)</li><li>sender의 buffer가 넘어가지 않도록 속도를 조절해서 보내는 것.
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-flowcontrol-buffer.png alt=IMAGE></li><li>rwnd: receive window, TCP header 값. 패킷 보낼때 마다 써서 보낸다.</li><li>rwnd에 따라 조절해서 전송</li></ul></li><li><p>connection management
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-connection-management.png alt=IMAGE></p><ul><li>sender와 receiver의 handshake</li><li>connection을 맺으면서 seq, rcvBuffer</li><li>2-way handshake
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-2way.png alt=IMAGE><ul><li>항상 잘 작동할까?<ul><li>variable delay</li><li>message loss</li><li>failure scenarios
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-2way-failure.png alt=IMAGE></li><li>2way는 모자라다.</li></ul></li></ul></li><li>3-way handshake
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-3way.png alt=IMAGE>
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-3way-fsm.png alt=IMAGE></li><li>TCP: closing connection<ul><li>4-way handshake<ul><li>FIN bit가 1인 Segment를 보낸다.</li><li>받은 FIN에 ACK 응답
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-4way.png alt=IMAGE></li></ul></li></ul></li></ul></li></ul><h2 id=6-principles-of-congestion-control>6. principles of congestion control</h2><p>패킷이 너무 많이 생겼을 때<br>RTT가 너무 많아졌을 때, 덜 만들자</p><ul><li>Congestion<ul><li>&ldquo;source가 데이터를 너무 많이, 빨리 보내서 네트워크가 이를 처리하기 어려운 상태&rdquo;</li><li>flow control과는 다르다<ul><li>flow control: 상대방 버퍼 문제</li><li>congestion control: 전체 데이터 문제</li></ul></li><li>manifestation<ul><li>lost packet (router-buffer overflow)</li><li>long delay (router-buffer queueing)</li></ul></li><li>top-10 problem!<ul><li>delay가 커지고, loss가 커지면 congestion</li></ul></li><li>Scenario 1<ul><li>one router, infinite buffer
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-congestion-scenario1.png alt=IMAGE></li></ul></li><li>Scenario 2<ul><li>one router, finite buffer
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-congestion-scenario2.png alt=IMAGE></li><li>Idealization: packet knowledge<ul><li>sender가 router가 available한 상태일 때만 전송한다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-congestion-scenario2-ideal.png alt=IMAGE></li></ul></li><li>Idealization: known loss<ul><li>sender가 패킷이 손실된 걸 알고 다시 보낸다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-congestion-scenario2-ideal2.png alt=IMAGE></li></ul></li><li>Realistic: duplication<ul><li>패킷은 송실될 수 있고</li><li>congestion<ul><li>다시보낸 것까지 감안한 성능이 &ldquo;good put&rdquo;
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-congestion-scenario2-real.png alt=IMAGE></li></ul></li></ul></li></ul></li><li>Scenario 3<ul><li>sender 4개</li><li>multihop paths</li><li>timeout / retransmit
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-congestion-scenario3.png alt=IMAGE>
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-tcp-congestion-scenario3-2.png alt=IMAGE></li></ul></li></ul></li></ul><h2 id=7-tcp-congestion-control>7. TCP congestion control</h2><ul><li><strong>additive increase, multiplicate decrease</strong><ul><li>증가할 땐 합 적용, 감소할땐 곱적용<ul><li>cwnd 1씩 증가: 1 -> 2 -> 3 -. &mldr; -> 99 -. 100</li><li>cwnd 절반으로 감소: 100 -> 50 -> 25
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-congestion-control.png alt=IMAGE>
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-congestion-control-cwnd.png alt=IMAGE></li></ul></li><li>cwnd deafult: 4096 -> 2048 -> 1024 &mldr;.</li><li>TCP sending rate
$$ rate ~~= cwnd/RTT (bytes / sec) $$</li></ul></li><li>TCP slow start
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-congestion-control-slotstart.png alt=IMAGE><ul><li>initially cwnd = 1 MSS</li><li>double cwnd every RTT</li><li>처음 rate는 slow, 점점 지수적 증가</li></ul></li><li>TCP: detecting, reacting to loss<ul><li>timeout이 걸린다:<ul><li>cwnd를 1로 셋팅 (반으로 줄이는 게 아니라)</li><li>slot start</li></ul></li><li>TCP RENO: 똑같은 ACK가 3개 (중간에 몇개 빼먹었다)<ul><li>cwnd를 반으로</li></ul></li><li>TCP Tahoe: 항상 cwnd를 1로<ul><li>(timeout 이건, 중복 3개 ACK건)</li></ul></li><li>TCP: switching from slow start to CA (Congestion Avoidance)
<img src=https://actumn.github.io/images/kucse-computer-network-2/transport-congestion-control-switching.png alt=IMAGE><ul><li>variable ssthresth<ul><li>sshthresh 까지는 지수적으로 증가</li><li>sshthresh 넘어가면 linear하게</li><li>문제가 발생하면 (timeout, duplicate ack 3)<ul><li>Tahoe에선 1</li><li>RENO에선 반으로.</li><li>sshthresh는 직전 cwnd의 절반</li></ul></li></ul></li></ul></li></ul></li><li>TCP throughput<ul><li>W: window size
$$ (avg.TCP throughput) = 3/4*W/RTT (bytes/s) $$</li></ul></li></ul><h1 id=chapter-4-network-layer-the-data-plane>Chapter 4: Network Layer: The Data plane</h1><h2 id=1-overview-of-network-layer>1. Overview of Network layer</h2><ul><li>Network layer<ul><li>End-to-End</li><li>모든 router에 ip 가 필요 (switch, 기지국에는 필요없다)</li><li>router는 header를 조사해서 next를 찾는다</li><li>router별 network layer: routing table</li></ul></li><li>기능<ul><li>Forwarding<ul><li>다음번 hop을 찾아서 보내는 것</li></ul></li><li>Routing<ul><li>길 찾기</li><li>최단 경로 찾기: routing alogrithm</li></ul></li></ul></li><li>Data plane<ul><li>forwarding 역할<ul><li>다음 번 hop이 어디인가</li></ul></li></ul></li><li>Control plane<ul><li>전체 routing algorithm 돌려서 경로설정</li><li>Network-wide</li><li>traditional routing algorithm: 라우터에 구현</li><li>SDN: server에서 구현</li></ul></li><li>Per-router control plane
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-control-router.png alt=IMAGE><ul><li>라우터마다 control plane</li><li>자기 라우팅은 자기가 계산</li><li>주기적으로 control plane 돌려서 routing table 갱신</li><li>기존 router에선 control plane, data plane이 분리되어 있지 않음</li></ul></li><li>Locally centralized control plane
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-control-centralized.png alt=IMAGE><ul><li>서버에서 라우팅 관리</li></ul></li><li>Network service model<ul><li>Sender와 receiver 사이의 channel 역할</li><li>individual datagram services<ul><li>guaranteed delivery</li><li>guaranteed delivery (&lt; 40 ms delay)</li></ul></li><li>flow of datagram services<ul><li>in-order delivery</li><li>guaranteed minimum bandwidth</li><li>packet inter spacing: 어느정도 띄워서 보낸다</li></ul></li><li>이런거 다 안된다! 오늘날 인터넷은 그저 best effort. guarantee는 없다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-control-models.png alt=IMAGE></li></ul></li></ul><h2 id=2-whats-inside-a-router>2. What's inside a router</h2><p><img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-architecture.png alt=IMAGE></p><ul><li>Input port functions
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-input.png alt=IMAGE><ul><li>line termination: physical layer</li><li>link layer protocol: datalink layer</li><li>lookup, forwarding: deccentralized switching<ul><li>ip header를 보고 &ldquo;matching&rdquo;, next hop을 찾고</li><li>목표: &ldquo;line speed&rdquo; processing</li><li>queueing</li><li>destination-based forwarding: destination 주소만 본다 (traditional)</li><li>generalized forwarding</li></ul></li></ul></li><li>Destination-basesd forwarding
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-forwarding.png alt=IMAGE><ul><li>longest prefix matching
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-forwarding-prefix.png alt=IMAGE><ul><li>TCAM (ternary content addressable memories)<ul><li>matching 되는 컨탠츠로 찾겠다.</li><li>ns 단위로 처리 가능</li><li>content addressable</li></ul></li></ul></li><li>Switching fabrics
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-fabrics.png alt=IMAGE></li><li>switching rate: rate at which packets can be transfer from inputs to outputs</li></ul></li><li>Switching via memory<ul><li>1 세대.</li><li>copy 때문에 느리다.</li></ul></li><li>Switching via a bus<ul><li>bus contention. 버스 성능에 따라 속도가 제한</li><li>Cisco 5600: 32 Gbps bus. enterprise router로 충분</li></ul></li><li>Switching via interconnection network<ul><li>bus가 여러개: bus bandwidth limitation 극복</li><li>banyan network (중요한 곳만 연결), crossbar, other interconnection nets</li><li>Cisco 12000: 60Gbps. 망 연결할 때 많이 쓴다.<ul><li>KT 망 - KONKUK 망 - SK 망</li></ul></li></ul></li><li>Input port queueing
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-queuing.png alt=IMAGE><ul><li>HOL (Head of the line) Blocking: 큐의 처음 부분이 다른 애들이 나아가는걸 막는다.</li><li>보통 queueing을 한다고 하면 output port에만</li></ul></li><li>Output port
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-output.png alt=IMAGE><ul><li>HOL 문제 해결</li><li>주로 router/swtich.</li><li>보통 output port에 버퍼링한다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-output-queuing.png alt=IMAGE></li><li>HOL 문제가 없어서 queuing delay가 훨씬 줄어든다.</li></ul></li><li>buffering을 얼마나 할 것인가?<ul><li>N: flow 포트 수. C: capacity
$$ RTT * C / \sqrt(N) $$</li><li>ex) RTT: 250ms, C = 10Gbps, N: 16 포트</li><li>계산결과: 2.5G bits ..?</li></ul></li><li>Scheduling mechanisms
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-scheduling.png alt=IMAGE><ul><li>scheduling. 큐가 여러개라면 어떤 패킷을 처리할 것인가</li><li>FIFO scheduling<ul><li>먼저 들어오는 패킷을 먼저 처리</li><li>discard policy: 큐가 꽉 찼다면<ul><li>tail drop: 나중에 들어온거</li><li>priority: 우선순위 낮은거</li><li>random: 임의</li></ul></li></ul></li><li>Scheduling policies: priority
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-scheduling-priority.png alt=IMAGE><ul><li>multiple classes: 여러 priority. header에 marking 필요</li><li>비율을 잘 맞춰야 한다. high N개 할 때마다 low 1개씩.</li></ul></li><li>Round Robin (RR) scheduling:
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-scheduling-rr.png alt=IMAGE><ul><li>돌아가면서</li></ul></li><li>Weighted Fair Queueing (WFQ)
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-router-scheduling-wfq.png alt=IMAGE><ul><li>Round Robin 일반화.<ul><li>highest: 3개씩</li><li>middle: 2개씩</li><li>lowest: 1개씩</li></ul></li></ul></li></ul></li></ul><h2 id=3-ip-internet-protocol>3. IP: Internet Protocol</h2><p><img src=https://actumn.github.io/images/kucse-computer-network-2/network-ip.png alt=IMAGE>
best effort.</p><ul><li>IP datagram format
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ip-datagram.png alt=IMAGE><ul><li>length: $2^{16}$ = 64KB 최대.</li><li>16-bit identifier, fragment offset: MTU로 짜르고, 모은다</li><li>upper layer: TCP, UDP</li><li>TCP 20 bytes, IP 20 bytes, App layer overhead</li></ul></li><li>IP fragmentation, reassembly<ul><li>패킷을 MTU 단위로 쪼개는 걸 fragmentation, 모으는 걸 reassemble</li><li>identification, offset으로 모은다</li><li>example
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ip-fragmentation.png alt=IMAGE><ul><li>offset은 octet단위</li></ul></li></ul></li><li>IP addressing
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ip-address.png alt=IMAGE><ul><li>IP: 32-bit identifier</li><li>interface: connection between host/router and physical link</li><li>IP주소는 매 인터페이스마다 할당</li><li><strong>subnet mask</strong></li></ul></li><li>Subnets
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ip-subnets.png alt=IMAGE><ul><li>IP address<ul><li>subnet part</li><li>host part</li></ul></li><li>Subnet<ul><li>라우터 거치지 않고 서로 접근 가능한 영역
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ip-subnets-count.png alt=IMAGE></li><li>얘는 서브넷이 6개다.</li><li>CIDR이 /30 이면 호스트가 2개 (00: network address, 11: broadcast address)</li></ul></li><li>CIDR: Classless InterDomaion Routing
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ip-cidr.png alt=IMAGE><ul><li>CIDR로 라우팅테이블 크기를 줄일 수 있다.</li></ul></li></ul></li><li>IP addresses: how to get one?<ul><li>hard-coded by system admin in a file. 수동으로 파일에 박아 넣는다.<ul><li>Windows: control-panel &mldr;</li><li>UNIX: /etc/rc.config</li></ul></li><li>DHCP<ul><li>dynamic 할당 / 반납</li><li>renew 가능</li><li>address 재사용 허용</li><li>더 많은 모바일 유저</li></ul></li><li>DHCP Overview<ul><li>host가 서브넷에 들어오면 &ldquo;DHCP discover&rdquo; broadcast</li><li>DHCP server responds with &ldquo;DHCP offer&rdquo;</li><li>host request &ldquo;DHCP request&rdquo;</li><li>server sends address &ldquo;DHCP ack&rdquo;</li><li>Well-known port: 68</li></ul></li><li>DHCP: more than IP address<ul><li>DHCP 는 IP address 할당 그 이상의 일을 한다</li><li>router의 IP를 같이 준다</li><li>DNS Server의 이름과 주소</li><li>network mask</li></ul></li><li>DHCP: example
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ip-dhcp-example.png alt=IMAGE><ul><li>laptop에서 필요한거: 자기 주소, DNS, router</li><li>DHCP request: UDP, IP, Ehternet으로 encapsulate</li><li>Ehternet frame은 LAN에서 broadcast</li></ul></li><li>그러면 실제로 IP를 어디서 갖고오지?<ul><li>한국: KRNIC.NET -> KT, SKT</li><li>전세계: ICANN</li></ul></li><li>How does an ISP get block of addresses?<ul><li>ICANN: Internet Corporation for Assigned</li><li>allocates addresses</li><li>manages DNS</li><li>assgin domain names, resolve disputes</li></ul></li></ul></li><li>NAT: network address translation
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ip-nat.png alt=IMAGE><ul><li>single NAT IP address, different port -> different local addresses</li><li>motivaltion<ul><li>주소 1개를 여러 디바이스가 공유 (6만개)</li><li>로컬 네트워크에서 주소 변경<ul><li>외부엔 알리지 않아도 된다</li></ul></li><li>ISP에 비해 편리하다</li><li>보안요소<ul><li>디바이스가 바깥세상에서 Visible 하지 않으므로</li></ul></li></ul></li><li>Implementation: NAT router<ul><li>outgoing datagrams replace<ul><li>(source IP, port) -> (NAT IP, new port)</li></ul></li><li>remember</li><li>incoming datagrams replace (&ldquo;NAT table&rdquo;)
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ip-nat-table.png alt=IMAGE></li><li>16-bit port-number field</li><li>단점<ul><li>router는 layer 3 까지만 처리해야한다.</li><li>address 부족은 IPv6에서 해결되어야 한다.</li><li>end-to-end 위반<ul><li>NAT는 중개자가 필요하다</li></ul></li><li>NAT traversal<ul><li>Server에 직접 연결하고 싶을 떈? 방법이 없다.</li></ul></li></ul></li></ul></li></ul></li><li>IPv6<ul><li>motivation<ul><li>initial motivation: 32-bit address space가 모자르다</li><li>additional motiviation (header)<ul><li>processing / forwarding speed up</li><li>QoS</li></ul></li></ul></li><li>IPv6 datagram format<ul><li>fixed-length 40 byte header</li><li>꼭 필요한 것만 있다<ul><li>option이 없다.</li><li>fragmentation을 허용하지 않는다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ipv6-datagram.png alt=IMAGE></li><li>flow label: QoS support<ul><li>flow 가 무엇인가. src ~ dest로 연속해서 만드는 패킷들의 집합 (stream). 아직 잘 정의되진 않음</li></ul></li><li>payload len: data length</li><li>next hdr: UDP냐 TCP 등의 추가 header. Next hdr에서.</li><li>hop limit: TTL reply 횟수</li><li>IPv4옵션 (여기 routing 해라) 가 없다.</li><li>fragmentaation, ID가 없다. flow label이 생김</li><li>단순화했음에도 헤더의 길이가 늘어났다. address가 32bits -> 128bits가 됐으므로</li></ul></li></ul></li><li>Other changes from IPv4<ul><li>Checksum. 단순화 시키기 위해 삭제. 통신장비의 성능이 좋아져서 error도 적다. processing time을 줄이기 위해</li><li>options: 허요, 하지만 Next header field에서.</li><li>ICMPv6: new version of ICMP<ul><li>additional message type: &ldquo;Packet Too Big&rdquo;</li><li>multicast group management functions</li></ul></li></ul></li><li>Transition from IPv4 to IPv6.<ul><li>사람들이 잘 안바꾼다.</li><li>동시에 모든 router를 upgrade할 수는 없다.<ul><li>no &ldquo;flag days&rdquo;</li><li>IPv4와 IPv6를 같이</li></ul></li><li>Tunneling
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ipv6-tunneling.png alt=IMAGE><ul><li>IPv6 datagram을 IPv4 datagram payload로 전송
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-ipv6-tunneling-packet.png alt=IMAGE></li></ul></li></ul></li><li>IPv6: adoption<ul><li>중국이 가장 많이 쓴다</li><li>Google: 8%의 client</li><li>NIST: 정부의 1/3 도메인</li><li>20년 정도 걸릴듯</li><li>20년간의 app 변경, WWW, Facebook, &mldr;</li></ul></li></ul></li></ul><h2 id=4-genralized-forward-and-sdn>4. Genralized Forward and SDN</h2><p>SDN: Network 가상화 기술. (Software Defined Network)<br>각 라우터의 control 모듈을 중앙서버에 모아두었다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-sdn.png alt=IMAGE>
각 라우터 별 flow table이 있고, flow table을 주고 받는 프롵콜 OpenFlow가 있다.</p><ul><li>OpenFlow data plane abstraction<ul><li>flow: 헤더 필드로 파악</li><li>rules<ul><li>Pattern: 매칭, 목적지, 주소가 어디라면</li><li>Actions: drop, forward, midify, 경우에 따라선 controller에게 보낸다</li><li>Priority: 우선순위 높은 놈붙터 처리</li><li>Counters: 통계. 매칭이 일어났을 때마다 +1
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-sdn-abstraction.png alt=IMAGE></li></ul></li></ul></li><li>OpenFlow: Flow table entries
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-sdn-openflow.png alt=IMAGE>
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-sdn-openflow-ex1.png alt=IMAGE>
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-sdn-openflow-ex2.png alt=IMAGE><ul><li>OpenFLow abstraction<ul><li>match + action: match와 action으로 서비스 정의</li><li>Router<ul><li>match: longest prefix</li><li>action: forward</li></ul></li><li>Switch<ul><li>match: destination MAC</li><li>action: forward or flood(broadcast)</li></ul></li><li>Firewall<ul><li>match: IP</li><li>action: permit or deny</li></ul></li><li>NAT<ul><li>match: IP and port</li><li>action: rewrite
<img src=https://actumn.github.io/images/kucse-computer-network-2/network-sdn-openflow-example.png alt=IMAGE></li></ul></li></ul></li></ul></li></ul><h1 id=chapter-5-network-layer-the-control-plane>Chapter 5: Network Layer: The control plane</h1><p>Chapter Goals</p><ul><li>traditional routing algorithm</li><li>SDN controllers</li><li>Internet Control Message Protocol: ICMP</li><li>network management: SNMP</li><li>OSPF: routing algorithm, BGP, <strong>OpenFlow</strong>, ODL, ONOS, ICMP, SNMP</li></ul><h2 id=1-introduction>1. Introduction</h2><ul><li>Network-layer functions<ul><li>forwarding: data plane</li><li>routing: control plane</li><li>Two approaches<ul><li>per-router control (traditional)</li><li>logically centralized control (software defined networking)</li></ul></li><li>Per-router control plane
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-intro-router.png alt=IMAGE></li><li>Logically centralized control plane
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-intro-centralized.png alt=IMAGE></li></ul></li></ul><h2 id=2-routing-protocols>2. Routing Protocols</h2><ul><li>goal: &ldquo;good&rdquo; path를 결정한다.<ul><li>&ldquo;good&rdquo;: least cost, feastest, least congested</li><li>routing: &ldquo;top-10&rdquo; challenge</li></ul></li><li>A link-state routing algorithm<ul><li>Dijkstra's algorithm<ul><li>다익스트라.</li><li>모든 노드가 완벽한 정보를 알고 있다. (그래프 연결, 엣지간 코스트 등)</li><li>그걸로 각자 계산</li><li>least cost path. 최소 경로를 찾자. 자기 자신부터 모든 노드까지</li><li>k iteration</li><li>notation<ul><li>C(x,y): x와 y 사이 cost</li><li>D(v): source부터 v까지 현재 최솟값</li><li>p(v): v까지 가는 경로의 직전 노드</li><li>N`: 현재까지 계산한 것중 확정된 것. 더 이상 짧은 길이 존재하지 않는다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-algorithm-linkstate.png alt=IMAGE></li><li>complexity<ul><li>$n(n+1)/2 = O(n^2)$</li><li>효율적인 구현: $O(nlogn)$</li></ul></li></ul></li><li>link state는 모든 노드가 다 각자 완벽한 그래프 정보를 수집, 각자 계산<ul><li>완벽한 정보를 수집하기 위해 broadcast</li><li>모든 정보가 교환될 떄 까지 계산 안하다가 한꺼번에 계산</li></ul></li></ul></li></ul></li><li>Distance vector algorithm<ul><li>이웃된 노드하고만 정보 교환</li><li>k 번 정보교환으로 routing table 완성</li><li>Bellman-ford
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-algorithm-ds.png alt=IMAGE></li><li>distance vector가 단순하니까 많이 쓰지만<ul><li>완벽한 정보를 모아서 계산하는게 아니라 현재 상태에서 계산.</li><li>실제로 라우터에선 RIP 하는 경우 30초마다 계산</li><li>maximum hop count가 15라고 한다면 7.5분이 걸린다.</li><li>중간에 링크 1개가 끊어지면?<ul><li>최정 경로 탐색까지 30초, 1분, 1분 30초, &mldr;. 걸리게 된다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-algorithm-ds-problem.png alt=IMAGE></li></ul></li></ul></li><li>Comparision of LS and DS algorithm<ul><li>message complexity<ul><li>LS: n 노드 수, e Edge 수 -> $O(nE)$</li><li>DV: neighbor 끼리만 exchange. convergence time이 가변적.</li></ul></li><li>speed of convergence<ul><li>LS: $O(n^2)$ for $O(nE)$ messages</li><li>DV: 가변적, LS보다 느리다</li></ul></li><li>robustness: router 하나가 고장나면?<ul><li>LS: 한꺼번에 broadcast<ul><li>중간에 hacker가 개입하지 않도록 authentication 해야함</li></ul></li><li>DV: error propagate 에 시간이 많이 걸린다.</li></ul></li></ul></li></ul></li></ul><h2 id=3-infra-as-routing-in-the-internet-ospf>3. Infra-AS routing in the Internet: OSPF</h2><ul><li>Making routing scalable<ul><li>망이 늘어남에 따라 목적지가 늘어난다.</li><li>routing table size가 기하급수적으로 늘어나면 안된다.</li><li>어떻게 줄일까?</li><li>이상적<ul><li>모든 router는 identical (똑같지 않다. 기관이 다르고 &mldr; 국가가 다르고 &mldr;)</li><li>network &ldquo;flat&rdquo;</li></ul></li><li>scale: 도착지가 몇십억<ul><li>router에 모든 주소를 다 넣을 수 없다!</li></ul></li><li>administrative autonomy<ul><li>망마다 자치</li><li>internet: 네트워크의 네트워크</li><li>각 network admin, 기관마다 네트워크 알아서 해라. (너네는 DV 해라, 우리는 LS 하겠다.)</li></ul></li></ul></li><li>Internet approach to scalable routing<ul><li>AS &ldquo;autonomous systems&rdquo;</li><li>Infra-AS routing<ul><li>기관 내 라이터들끼리 라우팅 프로토콜 알아서 해라</li></ul></li><li>Inter-AS routing<ul><li>기관 별, 바깥 세상 라우터끼리 정보교환</li></ul></li><li>Interconnected ASes
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-AS-inter.png alt=IMAGE></li></ul></li><li>Inter-AS tasks
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-AS-inter-tasks.png alt=IMAGE><ul><li>3a는 Intra-AS, Inter-AS 둘다 해야함.</li><li>Inter-AS<ul><li>3a->1c: AS3와 다른 네트워크 정보 전송</li><li>1c->3a: AS1, AS2, 그 외 네트워크 전보 3a에 전송</li></ul></li><li>Infra-AS<ul><li>교환해서 자기만 갖고 있을 게 아니라 propagate 필요</li></ul></li></ul></li><li>Intra-AS Routing<ul><li>IGP (Interior gateway protocols)</li><li>intra-AS의 대표적 프로토콜<ul><li>RIP: DV, metric: hop count</li><li>OSPF: Ls, metric: bandwidth/delay, metric이 단순 (IS-IS 존재)</li><li>IGRP: cisco가 만든, OSPF에서 발전한 protocol. metric이 복잡하다.</li></ul></li><li>OSPF (Open Shortest Path First)<ul><li>&ldquo;open&rdquo;: 오픈소스다.</li><li>link-state algorithm 사용<ul><li>link state broadcasting/flooding</li><li>topology가 각 노드에</li><li>그래서 dijkstra로 shortest least cost path를 찾아낸다.</li></ul></li><li>flooding 한다.<ul><li>IP를 통해서 flooding 정보 공유 (TCP나 UDP를 쓰지않음.)</li><li>link state</li></ul></li><li>Is-IS: OSPF랑 비숫</li></ul></li><li>OSPF &ldquo;advanced&rdquo; features<ul><li>security: authentication. (한 라우터가 잘못된 정보를 준다면 문제가 될 것.)</li><li>multiple: same-cost paths 동일한 값 path 허용 => load balancing (RIP에선 단 1 경로)</li><li>TOS 값에 따라 cost 측정 가능<ul><li>ex) satelite link 굉장히 느린데, 이메일 같은 건 이거 써도 됨.</li></ul></li><li>multicast 기능</li><li>hierarchical OSPF<ul><li>내부가 복잡하면 (건물 수십개) Flat보다 계층 라우팅이 효율적</li></ul></li></ul></li><li>Hierarchical OSPF
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-OSPF.png alt=IMAGE></li><li>area2 에서 area1 을 알 필요가 없다.</li><li>area별 OSPF</li><li>two-level hierarchy: local area, backbone<ul><li>link-state advertisements</li></ul></li><li>area border</li><li>backbone routers</li><li>boundary routers</li></ul></li></ul><h2 id=4-routing-among-the-isps-bgp>4. routing among the ISPs: BGP</h2><p>요즘 BGP 안쓰는 데가 없다.</p><ul><li>BGP (Border Gateway Protocol)<ul><li>사실상 inter-domain routing protocol</li></ul></li><li>BGP provides<ul><li>eBGP: external BGP<ul><li>나한테 주면 여기저기 보낼 수 있다는 AS정보를 받을 수 있다.</li></ul></li><li>iBGP: internal BGP<ul><li>받은 reachability information을 내부 라우터에 전달. 이렇게 forwarding table을 만든다.</li></ul></li><li>BGP에서 중요한건 policy<ul><li>intra-routing protocol에선 최소비용이 중요</li><li>inter-routing protocol에선 최소경로보다 &ldquo;reachability&rdquo;</li><li>그래서 reachability information 교환.</li></ul></li><li>다른 네트워크에 &ldquo;I am here"을 알려준다. 알려주지 않으면 reachability가 전달되지 않음.</li></ul></li><li>eBGP, iBGP connections
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-BGP.png alt=IMAGE><ul><li>BGP session: 두 BGP 라우터가 주기적으로 정보교환<ul><li>1개의 session을 만든다.</li><li>TCP connection으로 교환하는건 path vector
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-BGP-basic.png alt=IMAGE></li><li>AS 3, X 에게 보낼 수 있음을 알려줌</li></ul></li><li>Path attributes and BGP routes<ul><li>서로 교환하는 reachability information<ul><li>prefix + &ldquo;attributes&rdquo; = &ldquo;route&rdquo;</li><li>어떤 네트워크 + attributes</li></ul></li><li>Attributes에는<ul><li>AS-PATH: 이러이러한 경로를 통해 X까지 보내주겠다.</li><li>NEXT-HOP: 갈때 next hop이 뭐다.</li></ul></li><li>Policy-based routing<ul><li>정책적으로 결정한 바에 의해 routing 해주겠다. (reachability가 있다 / 없다)</li></ul></li></ul></li></ul></li><li>BGP path advertisement
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-BGP-path.png alt=IMAGE></li><li>BGP messages<ul><li>TCP 위에 connection 만들어서 정보 교환.<ul><li>OPEN: connection 만드는</li><li>UPDATE: path. 새로운 경로를 알려준다. 또는 policy로 인해 withdraw</li><li>KEEPALIVE: 계속 살린다</li><li>NOTIFICATION: 에러 발생시 알려준다</li></ul></li></ul></li><li>BGP: achieving policy via advertisements
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-BGP-policy.png alt=IMAGE><ul><li>BGP policy를 통해 transit traffic을 막을 수 있다.</li><li>x: dual-homed. 2개 이상의 네트워크와 연결</li></ul></li><li>Why different Intra-, Inter-AS routing?<ul><li>policy</li></ul></li><li>scale<ul><li>hierarchical을 통해 scale할 수 있다</li></ul></li><li>performance<ul><li>Inter-AS에선 policy가 더 중요</li></ul></li></ul><h2 id=5-sdn>5. SDN</h2><p>기존 라우터에서 하던 RIP, IP, IS-IS 등의 프로토콜을 전부 다른 서버/클라우드에서 한다 (control plane). data plane에는 하드웨어 기계만.<br>&ldquo;middlebox&rdquo;: 다른 layer의 firewalls, load balancer, NAT boxes 등도 control plane에 존재 가능<br>최근 네트워크는 SDN. 이동통신사, Google</p><ul><li>Why a logically centralized control plane?<ul><li>avoid router misconfiguration, great flexibility<ul><li>control을 맘대로 고칠 수 있다.</li><li>기존 hardware-based 에선 Cisco, Huawei가 라우터 안고쳐주더라.</li></ul></li><li>table-based forwarding으로 프로그래밍이 가능해진다<ul><li>centralizzed easier</li><li>distributed difficult: manufacturer가 입맞에 맞게 안고쳐주더라.</li></ul></li><li>open (non-proprietary)<ul><li>소유권이 개방. module program들이 모두 옾느소ㅡ</li></ul></li><li>비유
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-sdn-analogy.png alt=IMAGE></li></ul></li><li>Traffic engineering
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-sdn-traffic.png alt=IMAGE><ul><li><code>uxyz</code> 경로가 가장 빠른데, 로드밸런싱 목적으로 uvwz</li><li>SDN에서 traffic engineering하기 편하다.</li><li>tradition에선 바꾸기 어렵다.</li></ul></li><li>SDN perspective: data plane switches<ul><li>Switch도 SDN 이용 가능</li></ul></li><li>SDN perspective: SDN controller
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-sdn-controllers.png alt=IMAGE><ul><li>southbound API: openflow</li><li>northbound API: control plane은 controller가 필요</li></ul></li><li>Components of SDN controller
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-sdn-components.png alt=IMAGE><ul><li><strong>RESTful API</strong></li><li><strong>OpenFLow</strong></li></ul></li><li>OpenFlow protocol
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-sdn-openflow.png alt=IMAGE><ul><li>controller와 스위치 사이 작동</li><li>TCP 이용 + encryption</li><li>3가지 종류<ul><li>controller-to-switch</li><li>asynchronous (switch-to-controller)<ul><li>일방향. 문제발생 -> controller로 보낸다</li></ul></li><li>symmetric: 통계</li></ul></li><li>controller-to-swtich messages<ul><li>features: 스위치기능 query. 이때 switch reply</li><li>configure</li><li>modify-state: flow table operation</li><li>packet-out: 에러처리? controller can send this packet out of specific switch port</li></ul></li><li>switch-to-controller<ul><li>packet-in: 처리 못하겠으면 controller에게</li><li>flow-removed: 스위치에서 table entry가 삭제됐음을 보고</li><li>port status: port 상태 변화 전송</li></ul></li></ul></li><li>OpenDayloght (ODL) controller
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-sdn-odl.png alt=IMAGE><ul><li>ODL Lithium controller</li><li>OpenFlow 1.0, SNMP</li><li>RESTful API</li><li>SAl, Network service apps 다 오픈소스다.</li></ul></li><li>ONOS controller
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-sdn-onos.png alt=IMAGE><ul><li>통신회사에서 많이씀.</li></ul></li><li>SDN challenges<ul><li>control plane: 잘 만들어야 한다. dependable , reliable 등등 골고루 잘 들어가야함</li><li>rebustness to failures: 장애가 나더라도 잘 돌아가야한다.</li><li>dependability, security</li><li>networks<ul><li>ex) real-time, ultra-reliable, ultra-secure</li></ul></li></ul></li></ul><h2 id=6-icmp-the-internet-control-message-protocol>6. ICMP: The Internet Control Message Protocol</h2><p>에러가 나서 패킷을 버리게 되면 source에게 알려줘야 한다.</p><ul><li>ICMP: internet control message protocol<ul><li>Error reporting<ul><li>이유를 알려줘야 한다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-icmp-messages.png alt=IMAGE></li></ul></li><li>Echo -> ping</li><li>ICMP message<ul><li>type + code + 버린 패킷 8 bytes</li></ul></li></ul></li><li>Traceroute and ICMP<ul><li>첫 패킷은 TTL = 1 이걸 3번</li><li>다음은 TTL = 2
&mldr;</li><li>TTL = n</li><li>중간에 어떤 node가 문제가 있는지 알 수 있다.</li></ul></li></ul><h2 id=7-network-management-and-snmp>7. Network management and SNMP</h2><ul><li>autonomous systems: 1000개 이상의 hardware / software</li><li>다른 복잡한 시스템: management가 필요</li><li>Infrastructure for network management
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-snmp.png alt=IMAGE><ul><li>managed device: 관리를 위한 MIB (Management Information Base)</li><li>device 상태에 관한 Database</li><li>Two ways
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-snmp-2ways.png alt=IMAGE></li><li>message types
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-snmp-types.png alt=IMAGE></li><li>message formats
<img src=https://actumn.github.io/images/kucse-computer-network-2/control-snmp-formats.png alt=IMAGE></li></ul></li></ul><h1 id=6-the-link-and-lans>6. The Link and LANs</h1><ul><li>원칙<ul><li>error detection, correction (transfer의 error는 end-to-end)</li><li>이웃된 노드 연결 - channel. channel을 sharing 할 수도 (공기, bus)</li><li>link layer addressing: 48 bits</li><li>local area network: Ethernet, VLAN. Ehternet은 WAN에서도 쓰인다.</li></ul></li></ul><h2 id=1-link-layer-introduction>1. Link layer: introduction</h2><ul><li>terminology<ul><li>이웃된 노드간의 프로토콜<ul><li>host-router, router-router</li></ul></li><li>이웃된 노드간의 연결을 link라 한다.<ul><li>wired link: 유선. bandwidth 혼자 다 씀</li><li>wireless link: 무선. 기지국과 단말기. 느리고, 공유. host는 많음</li></ul></li><li>datalink layer의 통신 단위는 frame<ul><li>network packet<ul><li>ip: datagram</li><li>transport: stream (TCP), datagram (UDP)</li></ul></li></ul></li><li>data-link layer는 link로 연결된 물리적 이웃노드간 datagram을 전달해주는 역할 담당</li></ul></li><li>Link layer: context<ul><li>다른 링크라면 다른 link protocol<ul><li>ex) ehternet, frame relay, 802.11</li></ul></li><li>각 link protocol은 다른 서비스 제공<ul><li>reliable 혹은 reliabe하지 않음</li></ul></li></ul></li><li>Link layer services<ul><li>framing<ul><li>network, ip에서 packet / datagram을 줬다.</li><li>이웃된 노드에게 전달해야한다.<ul><li>header와 trailer를 붙여서 framing, encapsulate</li></ul></li><li>shared medium이라면 누가 access하게 할 것인가.</li><li>&ldquo;MAC&rdquo; 누가 매체를 차지하게 할 것인가.<ul><li>Medium Access Protocol. 이를 위한 주소 체계</li><li>header에 source | destination</li></ul></li><li>이웃된 노드 간 reliable delivery<ul><li>3장에서 하는 법을 배웠다.</li><li>low-bit error. (fiber, some twisted pair)</li><li>wireless links<ul><li>high error rates</li><li>왜 end-to-end reliability와 link-level reliablity 둘다 하지?</li><li>-> IP가 unreliable하다. 중간 router가 packet drop, 혹은 순서가 바뀔 수도</li><li>따라서 datalink에서 에러처리 해도 완벽하지 않다.</li></ul></li></ul></li></ul></li><li>flow control: 받는 놈이 받을 수 있을 만큼 준다</li><li>error detection: reliable service를 위해, 1의 보수 checksum</li><li>error correction: 다시 보내기, 중복해서 보내기</li><li>half-duplex and full-duplex<ul><li>half-duplex: 양방향. 한순간에 한쪽만</li><li>full-duplex: 양방향, 동싱통신</li></ul></li></ul></li><li>Where is the link later implemented?
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-intro-lancard.png alt=IMAGE><ul><li>LAN 카드. (또는 NIC 카드. Network Interface Card)</li><li>버스에 꼽혀있다.</li><li>Ehternet card, 802.11 card, Ethernet chipset</li><li>카드니까 hardware + software + firmware</li></ul></li><li>Adaptors communicating
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-intro-communicate.png alt=IMAGE><ul><li>sending side<ul><li>frame encapsulation: ip packet을 담는다</li><li>header에 LAN 카드 주소, checking bits</li></ul></li><li>receiving side<ul><li>error control</li><li>flow control</li><li>error recovery</li></ul></li></ul></li></ul><h2 id=2-error-detection>2. Error detection</h2><p><img src=https://actumn.github.io/images/kucse-computer-network-2/link-error.png alt=IMAGE>
EDC 체크해서 계산값과 같으면 -> 에러 X, 다르면 -> 에러</p><ul><li>Parity checking<ul><li>single bit parity
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-error-single.png alt=IMAGE><ul><li>1 bit error를 감지</li><li>odd number parity: 1의 갯수가 홀수인가</li><li>even number parity: 1의 갯수가 짝수인가</li><li>비트가 2개 바뀌면 못잡아낸다</li></ul></li><li>two-dimensional bir parity
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-error-twodimen.png alt=IMAGE><ul><li>얘도 비트가 많이 틀리면 못잡아낸다.</li><li>parity는 그냥 간단히 hardware 체크</li><li>checksum을 많이 한다. UDP에서 했다.</li></ul></li></ul></li><li>Cyclic redundancy check (CRC)
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-error-crc.png alt=IMAGE><ul><li>많이 쓴다.</li><li>G: 양쪽 값이 고정된 값.</li><li>$ D * 2^r \text{ XOR } R $ 값이 G로 나누어 떨어져야한다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-error-crc-example.png alt=IMAGE></li></ul></li></ul><h2 id=3-multiple-access-protocols>3. Multiple access protocols</h2><p>매체를 공유할 때 (공기, 버스의 경우) 누가 매체를 차지하게 할 것인가</p><ul><li><p>두 가지 link type</p><ul><li>point-to-point<ul><li>PPP</li><li>point-to-point link between Ethernet switch, host</li></ul></li><li>broadcast (매체를 공유하고 있음)<ul><li>upstream HFC: cable TV. 동축케이블 공유</li><li>802.11 wifi</li><li>인공위성</li></ul></li></ul></li><li><p>Multiple access protocols</p><ul><li>single shared broadcast channel<ul><li>channel을 sharing</li></ul></li><li>경우에 따라 2개 이상의 노드가 전송을 하면<ul><li>충돌 발생. 패킷이 개진다. 재전송이 필요해짐</li></ul></li><li>multiple access protocols. MAC protocol<ul><li>분산 알고리즘이다.</li><li>control signal을 보내는 채널이 따로 없다. (no out-of-band channel, coordination)</li><li>channel communication은 알아서 해야한다.</li></ul></li><li>An ideal multiple access protocol<ul><li>전체 channel capacity가 R bps 일때</li><li>desiderata<ul><li><ol><li>노드가 1개라면 R을 다 쓸수 있다.</li></ol></li><li><ol start=2><li>노드가 M개 있다고 하면 $R / M$ 만큼 갖게 해야함.</li></ol></li><li><ol start=3><li>fully decentralized</li></ol><ul><li>중앙 집중 노드가 없다. 알아서 해야한다.</li><li>no synchronization of clocks, slots</li></ul></li><li><ol start=4><li>단순할 수록 좋다.</li></ol></li></ul></li></ul></li></ul></li><li><p>MAC protocols: taxonomy</p><ul><li>channel partitioning: channel을 나눠쓴다.<ul><li>TDMA: time division multiple access. 시간을 slot으로 나눠 쓴다.</li><li>FDMA: frequency division multiple access. 주파수를 나눠서 사요</li><li>CDMA: Code division multiple access. chipset이 각자 encoding</li></ul></li><li>random access<ul><li>임의로 access. 충돌을 허용. recovery 방법 내장</li></ul></li><li>taking turns<ul><li>token 이 있어서 token 가진 애한테만 채널 사용</li><li>보낼 데이터가 많다면 혜택을 준다.</li></ul></li></ul></li><li><p>Channel partitioning MAC protocols: TDMA
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-mac-tdma.png alt=IMAGE></p><ul><li>TDMA: time division multiple slots</li><li>장점: 1slot만큼 bandwidth guarantee</li><li>단점: 안쓰는 애한테도 channel 할당</li></ul></li><li><p>Channel partitioning MAC protocols: FDMA
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-mac-fdma.png alt=IMAGE></p><ul><li>FDMA: frequency division multiple access</li><li>동시에 다 보내기는 하지만 전체적인 bandwidth는 $ R/n $. 안쓰는 애 낭비</li></ul></li><li><p>Random access protocols</p><ul><li>누구든지 쓰고 싶을 때 써라. 몇가지 조건<ul><li>send 하려는 노드가 있으면<ul><li>R을 혼자 다 쓴다.</li><li>중앙집중 노드가 coordination 하지 않음. 알아서 분산</li></ul></li><li>2개 이상의 노드가 전송 -> collision</li></ul></li><li>random access protocol spec<ul><li>collision detect 방법이 있어야함.</li><li>collision recover 방법이 있어야한다.</li></ul></li><li>examples<ul><li>slotted ALOHA</li><li>ALOHA</li><li>CSMA, CSMA/CD, CSMA/CA</li></ul></li></ul></li><li><p>Slotted ALOHA
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ra-slotted.png alt=IMAGE></p><ul><li>가정<ul><li>모든 프레임은 동일한 크기</li><li>time을 equal size slot으로 나눈다</li><li>slot이 시작할 때만 보낸다.</li><li>시작할 때만 보내므로 동기화</li><li>동시에 2개 이상의 노드가 보내면 충돌.</li><li>모든 노드가 collision detect 가능</li></ul></li><li>Operation<ul><li>보낼 데이터가 있으면 slot이 시작되는 시간까지 기다린다.</li><li>collision detection.<ul><li>가능하면 한다 -> Ethernet (CSMA/CD)<ul><li>ack 에러가 났다고 바로 보내면 다시 충돌. wait time 조절</li></ul></li><li>못하면 acknowledgement (CSMA/CA)<ul><li>온다: OK</li><li>안온다: 재전송</li></ul></li></ul></li></ul></li><li>pros<ul><li>single active node가 channel을 다 쓸 수 있다.</li><li>highly decentralized: node의 slot만 sync 필요</li><li>simple</li></ul></li><li>cons<ul><li>collision이 일어나면 slot 낭비</li><li>idel slot. 노는 slot이 있다.</li><li>node들이 collision detect 방법을 알고 있어야한다.</li><li>clock synchronization</li></ul></li></ul></li><li><p>Slotted ALOHA: efficiency</p><ul><li>n개의 경쟁: $ p(1-p)^{N-1} $ 확률로 성공.</li><li>MAX efficiency: $ Np(1-p)^{N-1} $</li><li>P를 잘 조절했을 때 최대 $ 1/e ~= 0.37 $</li><li>37%의 효율</li><li>그대로 단순해서 많이 쓴다.</li></ul></li><li><p>Pure (unslotted) ALOHA
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ra-unslotted.png alt=IMAGE></p><ul><li>unslotted ALOHA: simpler, no synchronization</li><li>기다리지 않는다. 데이터가 있으면 바로 보낸다.</li><li>충돌이 훨씬 많이 일어 날 것.</li></ul></li><li><p>Pure ALOHA efficiency</p><ul><li>$ p(1-p)^{N-1}(1-p)^{N-1} $</li><li>$ = p(1-p)^{@(N-1)} $</li><li>$ 1/2e ~= 18% $</li><li>Slotted ALOHA보다 효율이 나쁘다.</li></ul></li><li><p>CSMA (carrier sense mutliple access)</p><ul><li>CSMA: listen before transmit</li><li>보내기전에 채널, bus를 확인, 아무도 안보내면 내가 보낸다</li><li>channel을 sense해보면, 보내고 있을 때 전압이나 전류가 다르다.<ul><li>idel일 때만 보낸다.</li><li>busy할때는 기다린다.</li></ul></li><li>CSMA collisions<ul><li>여전히 collision은 발생</li><li>거리가 있고, propagation delay가 있으므로</li></ul></li><li>CSMA/CD (collision detection)<ul><li>CSMA/CD: mechanism이 있다.</li><li>보내놓고 충돌이 일어나는지 확인<ul><li>일어나면, 송신 중단 (재밍) 하고 나중에 아무도 안보낼 때 다시 보낸다.</li></ul></li></ul></li><li>Ethernet CSMA/CD algorithm<ul><li>충돌이 일어나고, 나중에 아무도 안보내서 다시 보냈더니 또 충돌이 일어날 수 있다.</li><li>binary backoff: $ 0 &lt; w &lt; 2^{J} $인 난수 w, 여기서 J는 충돌횟수.</li></ul></li><li>efficiency
$$ efficiency = 1 / (1 + 5t(prop)/t(trans))$$<ul><li>ALOHA보다 훨씬 좋다.</li></ul></li></ul></li><li><p>&ldquo;Taking turns&rdquo; MAC protocols</p><ul><li>channel partitioning MAC protocosl<ul><li>시분할 / 주파수 분할 / 코드분할</li><li>$1/N$</li></ul></li><li>random access MAC protocosl<ul><li>low load: single node가 channel 다 쓰는게 가능</li><li>high load: collision이 자주 일어나면 overhead</li></ul></li><li>&ldquo;taking turns&rdquo; protocols<ul><li>token등으로 돌아가면서 쓰게 한다.</li></ul></li></ul></li><li><p>polling
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-mac-turns-polling.png alt=IMAGE></p><ul><li>master: control signal</li><li>slave: 지시받은 대로 행동</li><li>concerns<ul><li>polling overhead: 일일히 물어봐야한다.</li><li>latency: 통신하는 데 걸리는 시간</li><li>SPoF (master)</li></ul></li></ul></li><li><p>token passing
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-mac-turns-token.png alt=IMAGE></p><ul><li>node끼리 token 전달</li><li>token있는 동안 데이터 전송 가능</li></ul></li><li><p>Cable access network
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-mac-cable.png alt=IMAGE></p><ul><li>이미 있는 cable network를 통해 인터넷을 한다.</li><li>spliter: downstream 데이터를 보고 cable TV 신호면 TV로, 인터넷 신호면 modem으로</li><li>cable network로 Internet frame, 케이블 TV chanelm, control.</li><li>downstream만 있는게 아니고, upstream 도 있다<ul><li>internet frame</li><li>TV remote control signal</li><li>control signal</li></ul></li><li>downstream, upstream 주파수 대역이 다르다.</li><li>downstream이 upstream보다 훨씬 빨라야 한다. 트래픽이 많을 것이므로<ul><li>multiple downstream 40Mbps, single CMTS가 40Mbps를 나눠서 전송</li><li>multiple upstream 30Mbps. upstream 데이터가 적으모로 모든 유저가 channel을 time slot으로 경쟁</li></ul></li><li>cable
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-mac-cable2.png alt=IMAGE><ul><li>기본적으로 FDM: upstream, downstream 모두 주파수 분할해서 쓴다</li><li>경우에따라 TDP upstream: 데이터가 downstream에 비해 많지 않으므로 time slot 경쟁</li></ul></li></ul></li><li><p>CSMA/CA</p><ul><li>무선에선 Collision Detection 불가.</li><li>멀리 가면 signal이 약해진다. collision이 일어나도 감지 불가</li><li>Collision Avoidance한다.</li></ul></li><li><p>Taking turns</p><ul><li>Polling from control: Bluetooth</li><li>Token passign: FDDI, token ring</li></ul></li></ul><h2 id=4-lans>4. LANs</h2><p>data link layer와 physical layer를 포함한다. (2개를 cover한다.)<br>link layer를 또 2개로 나눈다: <em>MAC</em>, <em>LLC</em> (logical link control)
LAN에서도 addressing한다. 48bits<br>ARP, Address Resolution Protocol<br>Ethernet 주소는 hardware board에 찍혀있다.<br>     자신의 IP는 쉽게 알 수 있다. 상대방의 주소는? IP는 알 수 있는데, Ethernet을 알려면 ARP 필요<br>Switch: 가장 유명한 link layer 장비<br>VLAN: 가상화</p><ul><li>Addressing<ul><li>32-bit IP address:<ul><li>network-layer 주소 체계</li><li>host를 찾을 땐 ip 주소로</li><li>application 찾아갈 땐 transport layer 16 bits port number</li></ul></li><li>MAC (or LAN, Ehternet, physcial) address:<ul><li>48 bit 주소</li><li>LAN 카드에 찍혀있다</li><li>1A-2F-BB-76-09-AD</li><li>ISP가 바뀌면 IP가 바뀌는데, MAC은 flat하다. (게층적이지 않음)</li></ul></li><li>LAN address and ARP
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-lan.png alt=IMAGE><ul><li>LAN카드에 고유의 MAC주소가 찍혀있다</li><li>서로 통신하려면 IP주소 또는 MAC주소를 알고 있어야 한다.</li></ul></li><li>LAN 주소<ul><li>MAC 주소는 IEEE에서 관리</li><li>회사가 IEEE에서 MAC주소를 받아서 장사한다.</li><li>전세계에서 unique</li></ul></li><li>비유<ul><li>MAC주소: 주민등록번호</li><li>IP: 우편번호</li></ul></li><li>flat address -> 이전되도 MAC은 안바뀐다. portability 우수</li><li>IP주소는 해당 네트워크에서 IPfmf qkedkdigka<ul><li>계층적: subnet과 host</li></ul></li><li>ARP: address resolution protocol<ul><li>IP는 DNS라던가 cache로 알아낸다.</li><li>LAN카드 주소는? ARP로 물어본다.</li><li>매 호스트마다 ARP table이 있어야한다, soft state: TTL 덕분에 시간 지나면 지워진다.<pre><code>IP | MAC | TTL
</code></pre></li><li>ARP broadcast: FF-FF-FF-FF-FF-FF<ul><li>자기 Ethernet, IP address를 뿌릴것</li><li>상대가 받아서 응답. 서로 ARP table update</li></ul></li><li>&ldquo;plug-and-play&rdquo;: 별도의 설정 없이 LAN카드가 알아서 다 한다.</li></ul></li><li>Addressing: routing to another LAN
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-lan-addressing.png alt=IMAGE><ul><li>같은 LAN이면 ARP, Ethernet 주소를 알게 된다.</li><li>A에서 B로 통신하려면?<ul><li>B의 Ethernet 주소를 모른다.</li><li>next hop인 router의 LAN카드 주소를 써서 보낸다.</li></ul></li></ul></li></ul></li><li>Ethernet<ul><li>token ring, FDDI, &mldr; 중에서 Ethernet이 이겼다.</li><li>chip 하나로 구현, multiple speeds. 10M에 연결하면 10M, 1G에 연결하면 1G</li><li>인터넷 초창기부터 쓰이고</li><li>단순, 싸다</li><li>speed가 10Mbps ~ 10Gbps
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ehternet.png alt=IMAGE><ul><li>bus broadcast</li><li>CS해도 collision overhead</li><li>요즘은 Media sharing 하지 않음.</li><li>스위치구조를 bus가 아닌 crossbar로, CSMA/CD하면 충돌 안일어난다.</li></ul></li><li>physical topology<ul><li>bus: 90년대 많이 씀
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ethernet-bus.png alt=IMAGE></li><li>star: 오늘날, switch 형태. CSMA/CD까지 하면 진짜 충돌 안일어난다.
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ethernet-star.png alt=IMAGE></li></ul></li><li>Ethernet frame structure
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ethernet-frame.png alt=IMAGE><ul><li>preamble<ul><li>synchronization 하기 위함</li><li>10101010으로 7bytes, 10101011로 마지막 1byte</li><li>이 패턴이 시작되면 프레임이 시작되는 걸 알 수 있다.</li><li>clock sync도 하고, 프레임 감지</li></ul></li><li>addresses: source, destination MAC 주소<ul><li>dest부터 시작하고 source가 있음</li></ul></li><li>type: 대부분 IP지만, Novell IPX, AppleTalk등 있음</li><li>CRC: cyclic redundancy check<ul><li>error detect: 에러나면 drop</li></ul></li></ul></li><li>Ethernet: unreliable, connectionless<ul><li>요즘은 에러가 정말 안난다.</li><li>하지만 에러가 나면 에러처리 안하고 drop</li><li>LAN 중 대부분 conectionless<ul><li>connection 만드는 LAN: ATM</li></ul></li><li>connectionless: handshaking 안한다. 데이터 있으면 보낸다.</li><li>unreliable: error가 있으면 drop<ul><li>에러나면 처리는 TCP 아니면 Applicatio, 또는 안하던가</li></ul></li><li>MAC protocol은 CSMA/CD, 에러나면 binary backoff</li></ul></li><li>802.3 ethernet standards: link & physcial layer<ul><li>802.3: CSMA/CD</li><li>MAC 위의 LLC는 생략되어 있다.</li><li>differnet speeds: 2Mbps, 10Mpbs, 100Mbps, 10Gbps&mldr;
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ethernet-standards.png alt=IMAGE></li><li>MAC protocol: ATM, token ring, CSMA/CD, CSMA/CA</li><li>Physical<ul><li>앞 숫자가 속도. 100BASE-Tx -> 100Mbps</li><li>T: Twisted pair, F: Fiber</li></ul></li></ul></li></ul></li><li>Ethernet switch<ul><li>link-layer device<ul><li>자기 포트로 오는 frame을 조사해서 MAC주소를 보고 다른 곳으로 전달</li><li>Bus건 Switch건 CSMA/CD<ul><li>물론 Switch의 경우 collision이 일어나지 않음. 다른 장비 호환성을 위해.</li></ul></li></ul></li><li>transparent<ul><li>host는 switch가 있는지 없는지 모른다.</li></ul></li><li>plug-and-play<ul><li>configure할 필요 없다.</li></ul></li><li>switch: multiple simulateneous transmissions
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ethernet-switch.png alt=IMAGE><ul><li>A->A`, B->B`가 동시에 발생해도 충돌이 일어나지 않는다.</li></ul></li><li>switch: self-learning
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ethernet-switch-self.png alt=IMAGE></li><li>Interconnecting switches
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ethernet-switch-multi.png alt=IMAGE><ul><li>매 스위치마다 self-learning</li></ul></li><li>Institutional network
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ethernet-switch-institution.png alt=IMAGE></li><li>Switches vs router
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ethernet-switch-routers.png alt=IMAGE></li><li>VLANs
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ethernet-vlan.png alt=IMAGE><ul><li>port-based VLAN<ul><li>물리적으로 1개의 switch</li><li>논리적으로 2개의 switch</li></ul></li><li>traffic isolation 된다</li><li>router에서 물리적 2개의 switch가 연결된 것 처럼 가능</li></ul></li><li>VLANS spanning multiple switches
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-ethernet-spanning.png alt=IMAGE><ul><li>포트는 16개. 조직이 커지면 switch 1개 더 연결</li><li>논리적으로 1개의 switch</li><li>VLAN 할땐 VLAN ID를 쓴다.</li><li>2개 LAN 연결로 spanning 할땐 802.1q VLAN. 2byte tag, tag control</li></ul></li></ul></li></ul><h2 id=5-link-virtualization-mpls>5. link virtualization: MPLS</h2><ul><li>Multiprotocol label switching (MPLS)
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-mpls.png alt=IMAGE><ul><li>IP: connectionless, 매 패킷을 독립적으로 전송</li><li>전파망: connection 위에 전송. 일단 1번 라우팅, 그 다음부턴 그대로 전송<ul><li>첫번째 연결에서 모든 라우팅이나 기타 요구사항으로 리소스 reserve, 이후 그 ID로 모든걸 다 한다.</li></ul></li><li>label: 20bit짜리. connection 만들어줘서, forwarding을 빨리 할 수 있다.<ul><li>routing은 이미 결정 되어 있으므로, ip header가 아닌 MLPS header를 보고 routing</li></ul></li><li>Virtual circuit (VC) 을 만들어서</li><li>IP header에 주소가 있긴 하다.</li></ul></li><li>MLPS capable router<ul><li>label-switched router</li><li>ip를 뒤져보지 않고, label을 뒤진다.<ul><li>MPLS forwading table 존재 (P는 독립적)</li></ul></li><li>flexibility: IP-목적지로 라우팅<ul><li>얘는 목적지만이 아닌, source 주소, QoS라우팅 가능</li><li>목적지가 같으면 항상 같은길</li><li>link fail이 났을 때: 좀 더 빨리 복구 가능<ul><li>pre-computed packup bath 지정 가능</li></ul></li></ul></li><li>MPLS vs IP paths
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-mpls-ip.png alt=IMAGE><ul><li>IP routing: destination 주소로만 forwarding</li><li>MPLS: source를 참고해서 flexible 하게<ul><li>fast forwarding 가능</li><li>security에서 유리</li><li>과금도 유리, label 단위, 시간 재기도 좋다.</li></ul></li></ul></li><li>MPLS signaling
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-mpls-signaling.png alt=IMAGE><ul><li>사용자 데이터를 보내기 전에 라우팅 정보, 커넥션 만들기, 끊기 등</li><li>control data를 보내는 걸 signaling이라 함</li><li>RSVP<ul><li>MPEG => bandwidth 보장 필요. &ldquo;reservation&rdquo;</li><li>Reservation Protocol</li><li>connection 만들 때 reservation</li></ul></li></ul></li><li>MPLS forwarding tables
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-mpls-tables.png alt=IMAGE><ul><li>in label: 들어오는 패킷 label</li><li>out label: 목적지가 A일 때 label을 붙여준다.<ul><li>locality: 들어올 때 10, 나갈때 6</li><li>label 중복 가능성이 있으므로</li></ul></li><li>dest: 목적지</li><li>out interface<ul><li>in-label, dest보고 결정.</li></ul></li></ul></li></ul></li><li>data center networking<ul><li>수 만개, 수십만개의 호스트로 구성<ul><li>아마존, 유튜브, Akamai, Google</li></ul></li><li>challenges<ul><li>각종 application이 있고, 수많은 유저가 있다.</li><li>어떻게 traffic을 분석해서 가장 효율적으로 access할 수 있을까?</li><li>load balancing: 데이터 센터 트래픽이 상당하므로 bottle neck 발생 가능</li></ul></li><li>Data center networks
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-center.png alt=IMAGE><ul><li>Tier-1 switch, Tier-2 switch, ToR: Top of the rack 스위치</li><li>load balancer: application-layer routing</li><li>rich interconnection among switches
<img src=https://actumn.github.io/images/kucse-computer-network-2/link-center-interconnects.png alt=IMAGE><ul><li>switch 간 bottleneck을 해결하기 위해</li><li>수많은 redundancy를 통해 reliability를 늘린다.</li><li>이 중 하나가 bottleneck이 걸리면 다른 곳으로 돌아가게. throughput을 늘리자.</li></ul></li></ul></li></ul></li></ul></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small"></span><br><a class="tag tag--primary tag--small" href=https://actumn.github.io/tags/lecture/>lecture</a>
<a class="tag tag--primary tag--small" href=https://actumn.github.io/tags/computer-science/>computer science</a>
<a class="tag tag--primary tag--small" href=https://actumn.github.io/tags/computer-network/>computer network</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/06/operating-system/ data-tooltip="Operating System"><i class="fa fa-angle-left"></i><span class="hide-xs hide-sm text-small icon-ml"></span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/04/%ED%98%91%EB%8F%99-%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-1/ data-tooltip="협동 분산 시스템 (1)"><span class="hide-xs hide-sm text-small icon-mr"></span><i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions><i class="fa fa-share-alt"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread><i class="fa fa-comment-o"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#><i class="fa fa-list"></i></a></li></ul></div><div id=disqus_thread><noscript>Please enable JavaScript to view the <a href=//disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2020 SunMyeong Lee.</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=1><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/06/operating-system/ data-tooltip="Operating System"><i class="fa fa-angle-left"></i><span class="hide-xs hide-sm text-small icon-ml"></span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://actumn.github.io/2020/04/%ED%98%91%EB%8F%99-%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-1/ data-tooltip="협동 분산 시스템 (1)"><span class="hide-xs hide-sm text-small icon-mr"></span><i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions><i class="fa fa-share-alt"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread><i class="fa fa-comment-o"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#><i class="fa fa-list"></i></a></li></ul></div></div><div id=share-options-bar class=share-options-bar data-behavior=1><i id=btn-close-shareoptions class="fa fa-close"></i><ul class=share-options></ul></div><div id=share-options-mask class=share-options-mask></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-remove"></i></div><img id=about-card-picture src="https://www.gravatar.com/avatar/8c162af52bd6a1258c11ddf087e2af65?s=110" alt><h4 id=about-card-name>SunMyeong Lee</h4><div id=about-card-bio>I love <em>language learning</em>, <em>development</em>, <em>open source</em></div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Student</div><div id=about-card-location><i class="fa fa-map-marker"></i><br>Seoul, Korea</div></div></div><div id=cover style=background-image:url(https://actumn.github.io/images/cover-v1.2.0.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin=anonymous></script><script src=https://actumn.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js></script><script lang=javascript>window.onload=updateMinWidth;window.onresize=updateMinWidth;document.getElementById("sidebar").addEventListener("transitionend",updateMinWidth);function updateMinWidth(){var sidebar=document.getElementById("sidebar");var main=document.getElementById("main");main.style.minWidth="";var w1=getComputedStyle(main).getPropertyValue("min-width");var w2=getComputedStyle(sidebar).getPropertyValue("width");var w3=getComputedStyle(sidebar).getPropertyValue("left");main.style.minWidth=`calc(${w1} - ${w2} - ${w3})`;}</script><script>$(document).ready(function(){hljs.configure({classPrefix:'',useBR:false});$('pre.code-highlight > code, pre > code').each(function(i,block){if(!$(this).hasClass('codeblock')){$(this).addClass('codeblock');}
hljs.highlightBlock(block);});});</script><script>var disqus_config=function(){this.page.url='https:\/\/actumn.github.io\/2020\/06\/computer-network-2\/';this.page.identifier='\/2020\/06\/computer-network-2\/'};(function(){if(window.location.hostname=="localhost"){return;}
var d=document,s=d.createElement('script');var disqus_shortname='hugo-tranquilpeak-theme';s.src='//'+disqus_shortname+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin=anonymous></script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
      CommonHTML: { linebreaks: { automatic: true } },
      tex2jax: { inlineMath: [ ['$', '$'], ['\\(','\\)'] ], displayMath: [ ['$$','$$'], ['\\[', '\\]'] ], processEscapes: false },
      messageStyle: 'none'
    });
  </script></body></html>